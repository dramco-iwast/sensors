Disassembly Listing for Power_Module
Generated From:
C:/Users/JonaCappelle/Documents/Github/sensors/firmware/Power_Module/dist/soundlevel/debug/Power_Module.debug.elf
6-jul-2021 14:31:29

---  C:/Users/JonaCappelle/Documents/Github/sensors/firmware/Power_Module/system/system.c  --------------
1:             /*  ____  ____      _    __  __  ____ ___
2:              * |  _ \|  _ \    / \  |  \/  |/ ___/ _ \
3:              * | | | | |_) |  / _ \ | |\/| | |  | | | |
4:              * | |_| |  _ <  / ___ \| |  | | |__| |_| |
5:              * |____/|_| \_\/_/   \_\_|  |_|\____\___/
6:              *                           research group
7:              *                             dramco.be/
8:              *
9:              *  KU Leuven - Technology Campus Gent,
10:             *  Gebroeders De Smetstraat 1,
11:             *  B-9000 Gent, Belgium
12:             *
13:             *         File: system.c
14:             *      Created: 2020-10-02
15:             *       Author: Geoffrey Ottoy
16:             *      Version: 2.0
17:             *
18:             *  Description: Basic system initialization for the oscillator and 
19:             *               I2C slave interface.
20:             * 
21:             */
22:            
23:            #include <pic16f18446.h>
24:            
25:            #include "system.h"
26:            #include "i2c1.h"
27:            #include "interrupt.h"
28:            
29:            void OSCILLATOR_Initialize(void);
30:            void PMD_Initialize(void);
31:            
32:            void SYSTEM_Initialize(uint8_t slave_address){ //MODIFIED (was void))
0C5B  0140     MOVLB 0x0
0C5C  00A1     MOVWF length
33:                
34:                PMD_Initialize();
0C5D  318B     MOVLP 0xB
0C5E  23DC     CALL 0x3DC
0C5F  318C     MOVLP 0xC
35:                OSCILLATOR_Initialize();
0C60  318B     MOVLP 0xB
0C61  2349     CALL 0x349
0C62  318C     MOVLP 0xC
36:                
37:                VREGCONbits.VREGPM = 1; // Low-Power Sleep mode enabled in Sleep
0C63  0150     MOVLB 0x10
0C64  1492     BSF VREGCON, 0x1
38:            //    Unused I/O pins should be configured as outputs and driven to a logic
39:            //    low state. Alternatively, connect a1k? to 10 k? resistor to VSS on unused
40:            //    pins to drive the output to logic low
41:                
42:                ANSELA = 0x00;
0C65  017E     MOVLB 0x3E
0C66  01B8     CLRF ANSELA
43:                ANSELB = 0x00;
0C67  01C3     CLRF ANSELB
44:                ANSELC = 0x00;
0C68  01CE     CLRF ANSELC
45:            
46:                TRISA = 0x00;
0C69  0140     MOVLB 0x0
0C6A  0192     CLRF TRISA
47:                TRISB = 0x00;
0C6B  0193     CLRF TRISB
48:                TRISC = 0x00;
0C6C  0194     CLRF TRISC
49:            
50:                LATA = 0xFF;
0C6D  30FF     MOVLW 0xFF
0C6E  0098     MOVWF LATA
51:                LATB = 0xFF;
0C6F  30FF     MOVLW 0xFF
0C70  0099     MOVWF LATB
52:                LATC = 0xFF;
0C71  30FF     MOVLW 0xFF
0C72  009A     MOVWF LATC
53:                
54:                I2C1_Initialize(slave_address);
0C73  0821     MOVF length, W
0C74  318C     MOVLP 0xC
0C75  24E6     CALL 0x4E6
0C76  318C     MOVLP 0xC
55:                
56:                GlobalInterruptEnable();
0C77  178B     BSF INTCON, 0x7
57:                PeripheralInterruptEnable();
0C78  170B     BSF INTCON, 0x6
58:            }
0C79  0008     RETURN
59:            
60:            // The SensorInterruptHandler allows the sensor-specific code to operate
61:            // interrupt-base.
62:            void SYSTEM_SetSensorISR(void (* SensorInterruptHandler)(void)){
63:                SetSensorInterruptHandler(SensorInterruptHandler);
64:            }
65:            
66:            // Clock setup
67:            void OSCILLATOR_Initialize(void){
68:                // NOSC HFINTOSC; NDIV 1; 
69:                OSCCON1 = 0x60;
0B49  3060     MOVLW 0x60
0B4A  0151     MOVLB 0x11
0B4B  008D     MOVWF OSCCON1
70:                // HFFRQ 32_MHz; 
71:                OSCFRQ = 0x06;
0B4C  3006     MOVLW 0x6
0B4D  0093     MOVWF OSCFRQ
72:            }
0B4E  0008     RETURN
73:            
74:            // Enable/disable peripheral modules
75:            void PMD_Initialize(void){
76:                // disable everything by default -> should be enabled by sensor
77:                PMD0 = 0xFF;
0BDC  30FF     MOVLW 0xFF
0BDD  014F     MOVLB 0xF
0BDE  0096     MOVWF PMD0
78:                
79:                PMD0bits.SYSCMD = 0; // enabled clocks to peripherals
0BDF  1396     BCF PMD0, 0x7
80:                
81:                PMD1 = 0xFF;
0BE0  30FF     MOVLW 0xFF
0BE1  0097     MOVWF PMD1
82:                PMD2 = 0xFF;
0BE2  30FF     MOVLW 0xFF
0BE3  0098     MOVWF PMD2
83:                PMD3 = 0xFF;
0BE4  30FF     MOVLW 0xFF
0BE5  0099     MOVWF PMD3
84:                PMD4 = 0xFF;
0BE6  30FF     MOVLW 0xFF
0BE7  009A     MOVWF PMD4
85:                PMD5 = 0xFF;
0BE8  30FF     MOVLW 0xFF
0BE9  009B     MOVWF PMD5
86:                PMD6 = 0xFF;
0BEA  30FF     MOVLW 0xFF
0BEB  009C     MOVWF PMD6
87:                PMD7 = 0xFF;
0BEC  30FF     MOVLW 0xFF
0BED  009D     MOVWF PMD7
88:            }
0BEE  0008     RETURN
---  C:/Users/JonaCappelle/Documents/Github/sensors/firmware/Power_Module/system/interrupt.c  -----------
1:             #include <xc.h>
2:             #include "interrupt.h"
3:             #include "i2c1.h"
4:             #include "i2c2.h"
5:             #include "adcc.h"
6:             
7:             void DefaultSensorInterruptHandler(void);
8:             void (* SensorInterruptHandler)(void) = &DefaultSensorInterruptHandler;
9:             
10:            // main interrupt handler
11:            void __interrupt() Interrupt_Handler (void)
0004  147E     BSF 0x7FE, 0x0
0005  3180     MOVLP 0x0
12:            {
13:                
14:                // handle sensor interrupt    
15:                SensorInterruptHandler();
0006  0141     MOVLB 0x1
0007  0855     MOVF 0xD5, W
0008  008A     MOVWF PCLATH
0009  0854     MOVF SensorInterruptHandler, W
000A  000A     CALLW
000B  3180     MOVLP 0x0
16:                
17:                
18:                // interrupt handler
19:            //    if(PIE0bits.IOCIE == 1 && PIR0bits.IOCIF == 1)
20:            //    {
21:            //        PIN_MANAGER_IOC();
22:            //    }
23:                if(INTCONbits.PEIE == 1)
000C  1F0B     BTFSS INTCON, 0x6
000D  280F     GOTO 0xF
000E  2810     GOTO 0x10
000F  2841     GOTO 0x41
24:                {
25:                    if(PIE3bits.SSP1IE == 1 && PIR3bits.SSP1IF == 1)
0010  014E     MOVLB 0xE
0011  1C19     BTFSS PIE3, 0x0
0012  2814     GOTO 0x14
0013  2815     GOTO 0x15
0014  281D     GOTO 0x1D
0015  1C0F     BTFSS PIR3, 0x0
0016  2818     GOTO 0x18
0017  2819     GOTO 0x19
0018  281D     GOTO 0x1D
26:                    {
27:                        I2C1_ISR();
0019  318E     MOVLP 0xE
001A  264D     CALL 0x64D
001B  3180     MOVLP 0x0
28:                    } 
001C  2841     GOTO 0x41
29:                    else if(PIE1bits.ADIE == 1 && PIR1bits.ADIF == 1)
001D  1C17     BTFSS PIE1, 0x0
001E  2820     GOTO 0x20
001F  2821     GOTO 0x21
0020  2829     GOTO 0x29
0021  1C0D     BTFSS PIR1, 0x0
0022  2824     GOTO 0x24
0023  2825     GOTO 0x25
0024  2829     GOTO 0x29
30:                    {
31:                        ADCC_ISR();
0025  318B     MOVLP 0xB
0026  23AB     CALL 0x3AB
0027  3180     MOVLP 0x0
32:                    }
0028  2841     GOTO 0x41
33:                    else if(PIE3bits.BCL2IE == 1 && PIR3bits.BCL2IF == 1)
0029  1D99     BTFSS PIE3, 0x3
002A  282C     GOTO 0x2C
002B  282D     GOTO 0x2D
002C  2835     GOTO 0x35
002D  1D8F     BTFSS PIR3, 0x3
002E  2830     GOTO 0x30
002F  2831     GOTO 0x31
0030  2835     GOTO 0x35
34:                    {
35:                        I2C2_BusCollisionISR();
0031  318B     MOVLP 0xB
0032  2337     CALL 0x337
0033  3180     MOVLP 0x0
36:                    }
0034  2841     GOTO 0x41
37:                    else if(PIE3bits.SSP2IE == 1 && PIR3bits.SSP2IF == 1)
0035  1D19     BTFSS PIE3, 0x2
0036  2838     GOTO 0x38
0037  2839     GOTO 0x39
0038  2841     GOTO 0x41
0039  1D0F     BTFSS PIR3, 0x2
003A  283C     GOTO 0x3C
003B  283D     GOTO 0x3D
003C  2841     GOTO 0x41
38:                    {
39:                        I2C2_ISR();
003D  3180     MOVLP 0x0
003E  2085     CALL 0x85
003F  3180     MOVLP 0x0
40:                    } 
0040  2841     GOTO 0x41
41:                    else
42:                    {
43:                        //Unhandled Interrupt
44:                    }
45:                }      
46:                else
47:                {
48:                    //Unhandled Interrupt
49:                }
50:            }
0041  107E     BCF 0x77E, 0x0
51:            
52:            void SetSensorInterruptHandler(void (* InterruptHandler)(void)){
53:                SensorInterruptHandler = InterruptHandler;
54:            }
55:            
56:            void DefaultSensorInterruptHandler(void){
57:                return;
58:            }
0B35  0008     RETURN
---  C:/Users/JonaCappelle/Documents/Github/sensors/firmware/Power_Module/system/i2c2.c  ----------------
1:             /**
2:               MSSP2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 i2c2.c
9:             
10:              @Summary
11:                This is the generated header file for the MSSP2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides APIs for driver for I2C2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC16F18446
18:                    Driver Version    :  2.02
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above
21:                    MPLAB 	          :  MPLAB X 5.20	
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include "i2c2.h"
52:            
53:            /**
54:              I2C Driver Queue Status Type
55:            
56:              @Summary
57:                Defines the type used for the transaction queue status.
58:            
59:              @Description
60:                This defines type used to keep track of the queue status.
61:             */
62:            
63:            typedef union
64:            {
65:                struct
66:                {
67:                        uint8_t full:1;
68:                        uint8_t empty:1;
69:                        uint8_t reserved:6;
70:                }s;
71:                uint8_t status;
72:            }I2C_TR_QUEUE_STATUS;
73:            
74:            /**
75:              I2C Driver Queue Entry Type
76:            
77:              @Summary
78:                Defines the object used for an entry in the i2c queue items.
79:            
80:              @Description
81:                This defines the object in the i2c queue. Each entry is a composed
82:                of a list of TRBs, the number of the TRBs and the status of the
83:                currently processed TRB.
84:             */
85:            typedef struct
86:            {
87:                uint8_t                             count;          // a count of trb's in the trb list
88:                I2C2_TRANSACTION_REQUEST_BLOCK *ptrb_list;     // pointer to the trb list
89:                I2C2_MESSAGE_STATUS            *pTrFlag;       // set with the error of the last trb sent.
90:                                                                    // if all trb's are sent successfully,
91:                                                                    // then this is I2C2_MESSAGE_COMPLETE
92:            } I2C_TR_QUEUE_ENTRY;
93:            
94:            /**
95:              I2C Master Driver Object Type
96:            
97:              @Summary
98:                Defines the object that manages the i2c master.
99:            
100:             @Description
101:               This defines the object that manages the sending and receiving of
102:               i2c master transactions.
103:             */
104:           
105:           typedef struct
106:           {
107:               /* Read/Write Queue */
108:               I2C_TR_QUEUE_ENTRY          *pTrTail;       // tail of the queue
109:               I2C_TR_QUEUE_ENTRY          *pTrHead;       // head of the queue
110:               I2C_TR_QUEUE_STATUS         trStatus;       // status of the last transaction
111:               uint8_t                         i2cDoneFlag;    // flag to indicate the current
112:                                                               // transaction is done
113:               uint8_t                         i2cErrors;      // keeps track of errors
114:           
115:           
116:           } I2C_OBJECT ;
117:           
118:           /**
119:             I2C Master Driver State Enumeration
120:           
121:             @Summary
122:               Defines the different states of the i2c master.
123:           
124:             @Description
125:               This defines the different states that the i2c master
126:               used to process transactions on the i2c bus.
127:           */
128:           
129:           typedef enum
130:           {
131:               S_MASTER_IDLE,
132:               S_MASTER_RESTART,
133:               S_MASTER_SEND_ADDR,
134:               S_MASTER_SEND_DATA,
135:               S_MASTER_SEND_STOP,
136:               S_MASTER_ACK_ADDR,
137:               S_MASTER_RCV_DATA,
138:               S_MASTER_RCV_STOP,
139:               S_MASTER_ACK_RCV_DATA,
140:               S_MASTER_NOACK_STOP,
141:               S_MASTER_SEND_ADDR_10BIT_LSB,
142:               S_MASTER_10BIT_RESTART,
143:               
144:           } I2C_MASTER_STATES;
145:           
146:           /**
147:            Section: Macro Definitions
148:           */
149:           
150:           /* defined for I2C2 */
151:           
152:           #ifndef I2C2_CONFIG_TR_QUEUE_LENGTH
153:                   #define I2C2_CONFIG_TR_QUEUE_LENGTH 1
154:           #endif
155:           
156:           #define I2C2_TRANSMIT_REG                       SSP2BUF                 // Defines the transmit register used to send data.
157:           #define I2C2_RECEIVE_REG                        SSP2BUF                 // Defines the receive register used to receive data.
158:           
159:           // The following control bits are used in the I2C state machine to manage
160:           // the I2C module and determine next states.
161:           #define I2C2_WRITE_COLLISION_STATUS_BIT         SSP2CON1bits.WCOL     // Defines the write collision status bit.
162:           #define I2C2_MODE_SELECT_BITS                   SSP2CON1bits.SSPM     // I2C Master Mode control bit.
163:           #define I2C2_MASTER_ENABLE_CONTROL_BITS         SSP2CON1bits.SSPEN    // I2C port enable control bit.
164:           
165:           #define I2C2_START_CONDITION_ENABLE_BIT         SSP2CON2bits.SEN      // I2C START control bit.
166:           #define I2C2_REPEAT_START_CONDITION_ENABLE_BIT  SSP2CON2bits.RSEN     // I2C Repeated START control bit.
167:           #define I2C2_RECEIVE_ENABLE_BIT                 SSP2CON2bits.RCEN     // I2C Receive enable control bit.
168:           #define I2C2_STOP_CONDITION_ENABLE_BIT          SSP2CON2bits.PEN      // I2C STOP control bit.
169:           #define I2C2_ACKNOWLEDGE_ENABLE_BIT             SSP2CON2bits.ACKEN    // I2C ACK start control bit.
170:           #define I2C2_ACKNOWLEDGE_DATA_BIT               SSP2CON2bits.ACKDT    // I2C ACK data control bit.
171:           #define I2C2_ACKNOWLEDGE_STATUS_BIT             SSP2CON2bits.ACKSTAT  // I2C ACK status bit.
172:           
173:           #define I2C2_7bit    true
174:           /**
175:            Section: Local Functions
176:           */
177:           
178:           void I2C2_FunctionComplete(void);
179:           void I2C2_Stop(I2C2_MESSAGE_STATUS completion_code);
180:           
181:           /**
182:            Section: Local Variables
183:           */
184:           
185:           static I2C_TR_QUEUE_ENTRY                  i2c2_tr_queue[I2C2_CONFIG_TR_QUEUE_LENGTH];
186:           static I2C_OBJECT                          i2c2_object;
187:           static I2C_MASTER_STATES                   i2c2_state = S_MASTER_IDLE;
188:           static uint8_t                             i2c2_trb_count = 0;
189:           
190:           static I2C2_TRANSACTION_REQUEST_BLOCK      *p_i2c2_trb_current = NULL;
191:           static volatile I2C_TR_QUEUE_ENTRY         *p_i2c2_current = NULL;
192:           
193:           
194:           /**
195:             Section: Driver Interface
196:           */
197:           #include "../sensor/veml7700.h"
198:           
199:           void I2C2_Initialize(void)
200:           {
201:               // Initialize pins
202:               PMD6bits.MSSP2MD = 0; // enable MSSP2
203:               
204:               VEML7700_SCL_SetLow();
205:               VEML7700_SCL_SetDigitalInput();
206:               VEML7700_SCL_SetDigitalMode();
207:               INLVLB = 0b01000000;
208:               
209:               VEML7700_SDA_SetDigitalMode();
210:               VEML7700_SDA_SetDigitalInput();
211:           
212:               // Map pins to I2C2 peripheral
213:               SSP2DATPPS = 0x0C;   //RB4->MSSP2:SDA2;    
214:               RB6PPS = 0x15;   //RB6->MSSP2:SCL2;    
215:               RB4PPS = 0x16;   //RB4->MSSP2:SDA2;    
216:               SSP2CLKPPS = 0x0E;   //RB6->MSSP2:SCL2;  
217:               
218:               i2c2_object.pTrHead = i2c2_tr_queue;
219:               i2c2_object.pTrTail = i2c2_tr_queue;
220:               i2c2_object.trStatus.s.empty = true;
221:               i2c2_object.trStatus.s.full = false;
222:           
223:               i2c2_object.i2cErrors = 0;
224:           
225:               // SMP High Speed; CKE disabled; 
226:               SSP2STAT = 0x00;
227:               // SSPEN enabled; CKP Idle:Low, Active:High; SSPM FOSC/4_SSPxADD_I2C; 
228:               SSP2CON1 = 0x28;
229:               // SBCDE disabled; BOEN disabled; SCIE disabled; PCIE disabled; DHEN disabled; SDAHT 100ns; AHEN disabled; 
230:               SSP2CON3 = 0x00;
231:               // SSPADD 3; 
232:               SSP2ADD = 0x4F;
233:               
234:               // clear the interrupt flags
235:               PIR3bits.SSP2IF = 0;
236:               PIR3bits.BCL2IF = 0;
237:           	
238:               // enable the interrupts
239:               PIE3bits.SSP2IE = 1;
240:               PIE3bits.BCL2IE = 1;
241:           }
242:           
243:                   
244:           uint8_t I2C2_ErrorCountGet(void)
245:           {
246:               uint8_t ret;
247:           
248:               ret = i2c2_object.i2cErrors;
249:               return ret;
250:           }
251:           
252:           void I2C2_ISR ( void )
253:           {
254:             
255:               static uint8_t  *pi2c_buf_ptr;
256:               static uint16_t i2c_address         = 0;
257:               static uint8_t  i2c_bytes_left      = 0;
258:               static uint8_t  i2c_10bit_address_restart = 0;
259:           
260:               PIR3bits.SSP2IF = 0;
0085  014E     MOVLB 0xE
0086  110F     BCF PIR3, 0x2
261:               
262:               // Check first if there was a collision.
263:               // If we have a Write Collision, reset and go to idle state */
264:               if(I2C2_WRITE_COLLISION_STATUS_BIT)
0087  0143     MOVLB 0x3
0088  1F9A     BTFSS SSP2CON1, 0x7
0089  288B     GOTO 0x8B
008A  288C     GOTO 0x8C
008B  29DF     GOTO 0x1DF
265:               {
266:                   // clear the Write colision
267:                   I2C2_WRITE_COLLISION_STATUS_BIT = 0;
008C  139A     BCF SSP2CON1, 0x7
268:                   i2c2_state = S_MASTER_IDLE;
008D  0140     MOVLB 0x0
008E  01D7     CLRF i2c2_state
269:                   *(p_i2c2_current->pTrFlag) = I2C2_MESSAGE_FAIL;
008F  0855     MOVF p_i2c2_current, W
0090  3E03     ADDLW 0x3
0091  0086     MOVWF FSR1
0092  0187     CLRF FSR1H
0093  0801     MOVF INDF1, W
0094  0086     MOVWF FSR1
0095  0187     CLRF FSR1H
0096  0181     CLRF INDF1
0097  0A81     INCF INDF1, F
270:           
271:                   // reset the buffer pointer
272:                   p_i2c2_current = NULL;
0098  01D5     CLRF p_i2c2_current
0099  2A03     GOTO 0x203
273:           
274:                   return;
275:               }
276:           
277:               /* Handle the correct i2c state */
278:               switch(i2c2_state)
01DF  0140     MOVLB 0x0
01E0  0857     MOVF i2c2_state, W
01E1  3A00     XORLW 0x0
01E2  1903     BTFSC STATUS, 0x2
01E3  289A     GOTO 0x9A
01E4  3A01     XORLW 0x1
01E5  1903     BTFSC STATUS, 0x2
01E6  28D3     GOTO 0xD3
01E7  3A03     XORLW 0x3
01E8  1903     BTFSC STATUS, 0x2
01E9  2925     GOTO 0x125
01EA  3A01     XORLW 0x1
01EB  1903     BTFSC STATUS, 0x2
01EC  2954     GOTO 0x154
01ED  3A07     XORLW 0x7
01EE  1903     BTFSC STATUS, 0x2
01EF  29D0     GOTO 0x1D0
01F0  3A01     XORLW 0x1
01F1  1903     BTFSC STATUS, 0x2
01F2  298D     GOTO 0x18D
01F3  3A03     XORLW 0x3
01F4  1903     BTFSC STATUS, 0x2
01F5  29A5     GOTO 0x1A5
01F6  3A01     XORLW 0x1
01F7  1903     BTFSC STATUS, 0x2
01F8  29D0     GOTO 0x1D0
01F9  3A0F     XORLW 0xF
01FA  1903     BTFSC STATUS, 0x2
01FB  29AC     GOTO 0x1AC
01FC  3A02     XORLW 0x2
01FD  1903     BTFSC STATUS, 0x2
01FE  28D6     GOTO 0xD6
01FF  3A01     XORLW 0x1
0200  1903     BTFSC STATUS, 0x2
0201  28FD     GOTO 0xFD
0202  29D5     GOTO 0x1D5
279:               {
280:                   case S_MASTER_IDLE:    /* In reset state, waiting for data to send */
281:           
282:                       if(i2c2_object.trStatus.s.empty != true)
009A  0141     MOVLB 0x1
009B  18A2     BTFSC 0xA2, 0x1
009C  289E     GOTO 0x9E
009D  289F     GOTO 0x9F
009E  2A03     GOTO 0x203
283:                       {
284:                           // grab the item pointed by the head
285:                           p_i2c2_current     = i2c2_object.pTrHead;
009F  0821     MOVF 0xA1, W
00A0  00F8     MOVWF 0xF8
00A1  0878     MOVF 0xF8, W
00A2  0140     MOVLB 0x0
00A3  00D5     MOVWF p_i2c2_current
286:                           i2c2_trb_count     = i2c2_object.pTrHead->count;
00A4  0141     MOVLB 0x1
00A5  0821     MOVF 0xA1, W
00A6  0086     MOVWF FSR1L
00A7  0187     CLRF FSR1H
00A8  0801     MOVF INDF1, W
00A9  00F8     MOVWF 0xF8
00AA  0878     MOVF 0xF8, W
00AB  0140     MOVLB 0x0
00AC  00D6     MOVWF i2c2_trb_count
287:                           p_i2c2_trb_current = i2c2_object.pTrHead->ptrb_list;
00AD  0141     MOVLB 0x1
00AE  0A21     INCF 0xA1, W
00AF  0086     MOVWF FSR1L
00B0  0187     CLRF FSR1H
00B1  3F40     MOVIW [0]FSR1
00B2  00F0     MOVWF 0xF0
00B3  3F41     MOVIW [1]FSR1
00B4  00F1     MOVWF 0xF1
288:           
289:                           i2c2_object.pTrHead++;
00B5  3004     MOVLW 0x4
00B6  00F8     MOVWF 0xF8
00B7  0878     MOVF 0xF8, W
00B8  07A1     ADDWF 0xA1, F
290:           
291:                           // check if the end of the array is reached
292:                           if(i2c2_object.pTrHead == (i2c2_tr_queue + I2C2_CONFIG_TR_QUEUE_LENGTH))
00B9  0821     MOVF 0xA1, W
00BA  3AD3     XORLW 0xD3
00BB  1D03     BTFSS STATUS, 0x2
00BC  28BE     GOTO 0xBE
00BD  28BF     GOTO 0xBF
00BE  28C3     GOTO 0xC3
293:                           {
294:                               // adjust to restart at the beginning of the array
295:                               i2c2_object.pTrHead = i2c2_tr_queue;
00BF  30CF     MOVLW 0xCF
00C0  00F8     MOVWF 0xF8
00C1  0878     MOVF 0xF8, W
00C2  00A1     MOVWF 0xA1
296:                           }
297:           
298:                           // since we moved one item to be processed, we know
299:                           // it is not full, so set the full status to false
300:                           i2c2_object.trStatus.s.full = false;
00C3  1022     BCF 0xA2, 0x0
301:           
302:                           // check if the queue is empty
303:                           if(i2c2_object.pTrHead == i2c2_object.pTrTail)
00C4  0821     MOVF 0xA1, W
00C5  0620     XORWF i2c2_object, W
00C6  1D03     BTFSS STATUS, 0x2
00C7  28C9     GOTO 0xC9
00C8  28CA     GOTO 0xCA
00C9  28CB     GOTO 0xCB
304:                           {
305:                               // it is empty so set the empty status to true
306:                               i2c2_object.trStatus.s.empty = true;
00CA  14A2     BSF 0xA2, 0x1
307:                           }
308:           
309:                           // send the start condition
310:                           I2C2_START_CONDITION_ENABLE_BIT = 1;
00CB  0143     MOVLB 0x3
00CC  141B     BSF SSP2CON2, 0x0
311:                           
312:                           // start the i2c request
313:                           i2c2_state = S_MASTER_SEND_ADDR;
00CD  3002     MOVLW 0x2
00CE  00F8     MOVWF 0x1F8
00CF  0878     MOVF 0x1F8, W
00D0  0140     MOVLB 0x0
00D1  00D7     MOVWF i2c2_state
00D2  2A03     GOTO 0x203
314:                       }
315:           
316:                       break;
317:           
318:                   case S_MASTER_RESTART:
319:           
320:                       /* check for pending i2c Request */
321:           
322:                       // ... trigger a REPEATED START
323:                       I2C2_REPEAT_START_CONDITION_ENABLE_BIT = 1;
00D3  0143     MOVLB 0x3
00D4  149B     BSF SSP2CON2, 0x1
00D5  28CD     GOTO 0xCD
324:           
325:                       // start the i2c request
326:                       i2c2_state = S_MASTER_SEND_ADDR;
327:           
328:                       break;
329:           
330:                   case S_MASTER_SEND_ADDR_10BIT_LSB:
331:           
332:                       if(I2C2_ACKNOWLEDGE_STATUS_BIT)
00D6  0143     MOVLB 0x3
00D7  1F1B     BTFSS SSP2CON2, 0x6
00D8  28DA     GOTO 0xDA
00D9  28DB     GOTO 0xDB
00DA  28E5     GOTO 0xE5
333:                       {
334:                           i2c2_object.i2cErrors++;
00DB  3001     MOVLW 0x1
00DC  00F8     MOVWF 0x1F8
00DD  0878     MOVF 0x1F8, W
00DE  0141     MOVLB 0x1
00DF  07A4     ADDWF 0xA4, F
335:                           I2C2_Stop(I2C2_MESSAGE_ADDRESS_NO_ACK);
00E0  3004     MOVLW 0x4
00E1  318C     MOVLP 0xC
00E2  2405     CALL 0x405
00E3  3180     MOVLP 0x0
336:                       }
00E4  2A03     GOTO 0x203
337:                       else
338:                       {
339:                           // Remove bit 0 as R/W is never sent here
340:                           I2C2_TRANSMIT_REG = (i2c_address >> 1) & 0x00FF;
00E5  0875     MOVF 0xF5, W
00E6  00F9     MOVWF 0xF9
00E7  0874     MOVF 0xF4, W
00E8  00F8     MOVWF 0xF8
00E9  36F9     LSRF 0xF9, F
00EA  0CF8     RRF 0xF8, F
00EB  0878     MOVF 0xF8, W
00EC  0096     MOVWF ADACC
341:           
342:                           // determine the next state, check R/W
343:                           if(i2c_address & 0x01)
00ED  1C74     BTFSS 0xF4, 0x0
00EE  28F0     GOTO 0xF0
00EF  28F1     GOTO 0xF1
00F0  28F7     GOTO 0xF7
344:                           {
345:                               // if this is a read we must repeat start
346:                               // the bus to perform a read
347:                               i2c2_state = S_MASTER_10BIT_RESTART;
00F1  300B     MOVLW 0xB
00F2  00F8     MOVWF 0xF8
00F3  0878     MOVF 0xF8, W
00F4  0140     MOVLB 0x0
00F5  00D7     MOVWF i2c2_state
348:                           }
00F6  2A03     GOTO 0x203
349:                           else
350:                           {
351:                               // this is a write continue writing data
352:                               i2c2_state = S_MASTER_SEND_DATA;
00F7  3003     MOVLW 0x3
00F8  00F8     MOVWF 0x78
00F9  0878     MOVF 0x78, W
00FA  0140     MOVLB 0x0
00FB  00D7     MOVWF i2c2_state
00FC  2A03     GOTO 0x203
353:                           }
354:                       }
355:           
356:                       break;
357:           
358:                   case S_MASTER_10BIT_RESTART:
359:           
360:                       if(I2C2_ACKNOWLEDGE_STATUS_BIT)
00FD  0143     MOVLB 0x3
00FE  1F1B     BTFSS SSP2CON2, 0x6
00FF  2901     GOTO 0x101
0100  2902     GOTO 0x102
0101  290C     GOTO 0x10C
361:                       {
362:                           i2c2_object.i2cErrors++;
0102  3001     MOVLW 0x1
0103  00F8     MOVWF 0x1F8
0104  0878     MOVF 0x1F8, W
0105  0141     MOVLB 0x1
0106  07A4     ADDWF 0xA4, F
363:                           I2C2_Stop(I2C2_MESSAGE_ADDRESS_NO_ACK);
0107  3004     MOVLW 0x4
0108  318C     MOVLP 0xC
0109  2405     CALL 0x405
010A  3180     MOVLP 0x0
364:                       }
010B  2A03     GOTO 0x203
365:                       else
366:                       {
367:                           // ACK Status is good
368:                           // restart the bus
369:                           I2C2_REPEAT_START_CONDITION_ENABLE_BIT = 1;
010C  149B     BSF ADPREV, 0x1
370:           
371:                           // fudge the address so S_MASTER_SEND_ADDR works correctly
372:                           // we only do this on a 10-bit address resend
373:                           i2c_address = 0x00F0 | ((i2c_address >> 8) & 0x0006);
010D  0875     MOVF 0xF5, W
010E  00F9     MOVWF 0xF9
010F  0874     MOVF 0xF4, W
0110  00F8     MOVWF 0xF8
0111  0879     MOVF 0xF9, W
0112  00F8     MOVWF 0xF8
0113  01F9     CLRF 0xF9
0114  3006     MOVLW 0x6
0115  0578     ANDWF 0xF8, W
0116  00FA     MOVWF 0xFA
0117  3000     MOVLW 0x0
0118  0579     ANDWF 0xF9, W
0119  00FB     MOVWF 0xFB
011A  30F0     MOVLW 0xF0
011B  047A     IORWF 0xFA, W
011C  00F4     MOVWF 0xF4
011D  3000     MOVLW 0x0
011E  047B     IORWF 0xFB, W
011F  00F5     MOVWF 0xF5
374:           
375:                           // set the R/W flag
376:                           i2c_address |= 0x0001;
0120  1474     BSF 0xF4, 0x0
377:           
378:                           // set the address restart flag so we do not change the address
379:                           i2c_10bit_address_restart = 1;
0121  0141     MOVLB 0x1
0122  01AD     CLRF i2c_10bit_address_restart
0123  0AAD     INCF i2c_10bit_address_restart, F
0124  28CD     GOTO 0xCD
380:           
381:                           // Resend the address as a read
382:                           i2c2_state = S_MASTER_SEND_ADDR;
383:                       }
384:           
385:                       break;
386:           
387:                   case S_MASTER_SEND_ADDR:
388:           
389:                       /* Start has been sent, send the address byte */
390:           
391:                       /* Note: 
392:                           On a 10-bit address resend (done only during a 10-bit
393:                           device read), the original i2c_address was modified in
394:                           S_MASTER_10BIT_RESTART state. So the check if this is
395:                           a 10-bit address will fail and a normal 7-bit address
396:                           is sent with the R/W bit set to read. The flag
397:                           i2c_10bit_address_restart prevents the  address to
398:                           be re-written.
399:                        */
400:                       if(i2c_10bit_address_restart != 1)
0125  0141     MOVLB 0x1
0126  032D     DECF i2c_10bit_address_restart, W
0127  1903     BTFSC STATUS, 0x2
0128  292A     GOTO 0x12A
0129  292B     GOTO 0x12B
012A  2947     GOTO 0x147
401:                       {
402:                           // extract the information for this message
403:                           i2c_address    = p_i2c2_trb_current->address;
012B  0870     MOVF 0xF0, W
012C  0086     MOVWF FSR1L
012D  0871     MOVF 0xF1, W
012E  0087     MOVWF FSR1H
012F  3F40     MOVIW [0]FSR1
0130  00F4     MOVWF 0xF4
0131  3F41     MOVIW [1]FSR1
0132  00F5     MOVWF 0xF5
404:                           pi2c_buf_ptr   = p_i2c2_trb_current->pbuffer;
0133  0870     MOVF 0xF0, W
0134  0086     MOVWF FSR1L
0135  0871     MOVF 0xF1, W
0136  0087     MOVWF FSR1H
0137  3143     ADDFSR 1, 3
0138  0801     MOVF INDF1, W
0139  00F8     MOVWF 0xF8
013A  0878     MOVF 0xF8, W
013B  0140     MOVLB 0x0
013C  00D4     MOVWF __pbssBANK0
405:                           i2c_bytes_left = p_i2c2_trb_current->length;
013D  0870     MOVF p_i2c2_trb_current, W
013E  0086     MOVWF FSR1
013F  0871     MOVF 0x71, W
0140  0087     MOVWF FSR1H
0141  3142     ADDFSR 1, 2
0142  0801     MOVF INDF1, W
0143  00F8     MOVWF 0x78
0144  0878     MOVF 0x78, W
0145  0141     MOVLB 0x1
0146  00AE     MOVWF i2c_bytes_left
406:                       }
407:           
408:                       // check for 10-bit address
409:                       if(!I2C2_7bit && (0x0 != i2c_address))
410:                       {  
411:                           if (0 == i2c_10bit_address_restart)
412:                           {
413:                               // we have a 10 bit address
414:                               // send bits<9:8>
415:                               // mask bit 0 as this is always a write                    
416:                               I2C2_TRANSMIT_REG = 0xF0 | ((i2c_address >> 8) & 0x0006);
417:                               i2c2_state = S_MASTER_SEND_ADDR_10BIT_LSB;
418:                           }
419:                           else
420:                           {
421:                               // resending address bits<9:8> to trigger read
422:                               I2C2_TRANSMIT_REG = i2c_address;
423:                               i2c2_state = S_MASTER_ACK_ADDR;
424:                               // reset the flag so the next access is ok
425:                               i2c_10bit_address_restart = 0;
426:                           }
427:                       }
428:                       else
429:                       {
430:                           // Transmit the address
431:                           I2C2_TRANSMIT_REG = i2c_address;
0147  0874     MOVF 0xF4, W
0148  0143     MOVLB 0x3
0149  0096     MOVWF SSP2BUF
432:                           if(i2c_address & 0x01)
014A  1C74     BTFSS 0x1F4, 0x0
014B  294D     GOTO 0x14D
014C  294E     GOTO 0x14E
014D  28F7     GOTO 0xF7
433:                           {
434:                               // Next state is to wait for address to be acked
435:                               i2c2_state = S_MASTER_ACK_ADDR;
014E  3005     MOVLW 0x5
014F  00F8     MOVWF 0x1F8
0150  0878     MOVF 0x1F8, W
0151  0140     MOVLB 0x0
0152  00D7     MOVWF i2c2_state
436:                           }
0153  2A03     GOTO 0x203
437:                           else
438:                           {
439:                               // Next state is transmit
440:                               i2c2_state = S_MASTER_SEND_DATA;
441:                           }
442:                       }
443:                       break;
444:           
445:                   case S_MASTER_SEND_DATA:
446:           
447:                       // Make sure the previous byte was acknowledged
448:                       if(I2C2_ACKNOWLEDGE_STATUS_BIT)
0154  0143     MOVLB 0x3
0155  1F1B     BTFSS SSP2CON2, 0x6
0156  2958     GOTO 0x158
0157  2959     GOTO 0x159
0158  2965     GOTO 0x165
449:                       {
450:                           // Transmission was not acknowledged
451:                           i2c2_object.i2cErrors++;
0159  3001     MOVLW 0x1
015A  00F8     MOVWF 0x1F8
015B  0878     MOVF 0x1F8, W
015C  0141     MOVLB 0x1
015D  07A4     ADDWF 0xA4, F
452:           
453:                           // Reset the Ack flag
454:                           I2C2_ACKNOWLEDGE_STATUS_BIT = 0;
015E  0143     MOVLB 0x3
015F  131B     BCF SSP2CON2, 0x6
455:           
456:                           // Send a stop flag and go back to idle
457:                           I2C2_Stop(I2C2_DATA_NO_ACK);
0160  3005     MOVLW 0x5
0161  318C     MOVLP 0xC
0162  2405     CALL 0x405
0163  3180     MOVLP 0x0
458:           
459:                       }
0164  2A03     GOTO 0x203
460:                       else
461:                       {
462:                           // Did we send them all ?
463:                           if(i2c_bytes_left-- == 0U)
0165  3001     MOVLW 0x1
0166  0141     MOVLB 0x1
0167  02AE     SUBWF i2c_bytes_left, F
0168  0A2E     INCF i2c_bytes_left, W
0169  1D03     BTFSS STATUS, 0x2
016A  296C     GOTO 0x16C
016B  296D     GOTO 0x16D
016C  2980     GOTO 0x180
464:                           {
465:                               // yup sent them all!
466:           
467:                               // update the trb pointer
468:                               p_i2c2_trb_current++;
016D  3004     MOVLW 0x4
016E  07F0     ADDWF 0xF0, F
016F  3000     MOVLW 0x0
0170  3DF1     ADDWFC 0xF1, F
469:           
470:                               // are we done with this string of requests?
471:                               if(--i2c2_trb_count == 0)
0171  3001     MOVLW 0x1
0172  0140     MOVLB 0x0
0173  02D6     SUBWF i2c2_trb_count, F
0174  1D03     BTFSS STATUS, 0x2
0175  2977     GOTO 0x177
0176  2978     GOTO 0x178
0177  297D     GOTO 0x17D
472:                               {
473:                                   I2C2_Stop(I2C2_MESSAGE_COMPLETE);
0178  3000     MOVLW 0x0
0179  318C     MOVLP 0xC
017A  2405     CALL 0x405
017B  3180     MOVLP 0x0
474:                               }
017C  2A03     GOTO 0x203
475:                               else
476:                               {
477:                                   // no!, there are more TRB to be sent.
478:                                   //I2C2_START_CONDITION_ENABLE_BIT = 1;
479:           
480:                                   // In some cases, the slave may require
481:                                   // a restart instead of a start. So use this one
482:                                   // instead.
483:                                   I2C2_REPEAT_START_CONDITION_ENABLE_BIT = 1;
017D  0143     MOVLB 0x3
017E  149B     BSF SSP2CON2, 0x1
017F  28CD     GOTO 0xCD
484:           
485:                                   // start the i2c request
486:                                   i2c2_state = S_MASTER_SEND_ADDR;
487:           
488:                               }
489:                           }
490:                           else
491:                           {
492:                               // Grab the next data to transmit
493:                               I2C2_TRANSMIT_REG = *pi2c_buf_ptr++;
0180  0140     MOVLB 0x0
0181  0854     MOVF __pbssBANK0, W
0182  0086     MOVWF FSR1
0183  0187     CLRF FSR1H
0184  0801     MOVF INDF1, W
0185  0143     MOVLB 0x3
0186  0096     MOVWF SSP2BUF
0187  3001     MOVLW 0x1
0188  00F8     MOVWF 0x1F8
0189  0878     MOVF 0x1F8, W
018A  0140     MOVLB 0x0
018B  07D4     ADDWF __pbssBANK0, F
018C  2A03     GOTO 0x203
494:                           }
495:                       }
496:                       break;
497:           
498:                   case S_MASTER_ACK_ADDR:
499:           
500:                       /* Make sure the previous byte was acknowledged */
501:                       if(I2C2_ACKNOWLEDGE_STATUS_BIT)
018D  0143     MOVLB 0x3
018E  1F1B     BTFSS SSP2CON2, 0x6
018F  2991     GOTO 0x191
0190  2992     GOTO 0x192
0191  299E     GOTO 0x19E
502:                       {
503:           
504:                           // Transmission was not acknowledged
505:                           i2c2_object.i2cErrors++;
0192  3001     MOVLW 0x1
0193  00F8     MOVWF 0x1F8
0194  0878     MOVF 0x1F8, W
0195  0141     MOVLB 0x1
0196  07A4     ADDWF 0xA4, F
506:           
507:                           // Send a stop flag and go back to idle
508:                           I2C2_Stop(I2C2_MESSAGE_ADDRESS_NO_ACK);
0197  3004     MOVLW 0x4
0198  318C     MOVLP 0xC
0199  2405     CALL 0x405
019A  3180     MOVLP 0x0
509:           
510:                           // Reset the Ack flag
511:                           I2C2_ACKNOWLEDGE_STATUS_BIT = 0;
019B  0143     MOVLB 0x3
019C  131B     BCF SSP2CON2, 0x6
512:                       }
019D  2A03     GOTO 0x203
513:                       else
514:                       {
515:                           I2C2_RECEIVE_ENABLE_BIT = 1;
019E  159B     BSF SSP2CON2, 0x3
516:                           i2c2_state = S_MASTER_ACK_RCV_DATA;
019F  3008     MOVLW 0x8
01A0  00F8     MOVWF 0x1F8
01A1  0878     MOVF 0x1F8, W
01A2  0140     MOVLB 0x0
01A3  00D7     MOVWF i2c2_state
01A4  2A03     GOTO 0x203
517:                       }
518:                       break;
519:           
520:                   case S_MASTER_RCV_DATA:
521:           
522:                       /* Acknowledge is completed.  Time for more data */
523:           
524:                       // Next thing is to ack the data
525:                       i2c2_state = S_MASTER_ACK_RCV_DATA;
01A5  3008     MOVLW 0x8
01A6  00F8     MOVWF 0x78
01A7  0878     MOVF 0x78, W
01A8  00D7     MOVWF i2c2_state
526:           
527:                       // Set up to receive a byte of data
528:                       I2C2_RECEIVE_ENABLE_BIT = 1;
01A9  0143     MOVLB 0x3
01AA  159B     BSF SSP2CON2, 0x3
529:           
530:                       break;
01AB  2A03     GOTO 0x203
531:           
532:                   case S_MASTER_ACK_RCV_DATA:
533:           
534:                       // Grab the byte of data received and acknowledge it
535:                       *pi2c_buf_ptr++ = I2C2_RECEIVE_REG;
01AC  0143     MOVLB 0x3
01AD  0816     MOVF SSP2BUF, W
01AE  00F8     MOVWF 0x1F8
01AF  0140     MOVLB 0x0
01B0  0854     MOVF __pbssBANK0, W
01B1  0086     MOVWF FSR1
01B2  0187     CLRF FSR1H
01B3  0878     MOVF 0x78, W
01B4  0081     MOVWF INDF1
01B5  3001     MOVLW 0x1
01B6  00F8     MOVWF 0x78
01B7  0878     MOVF 0x78, W
01B8  07D4     ADDWF __pbssBANK0, F
536:           
537:                       // Check if we received them all?
538:                       if(--i2c_bytes_left)
01B9  3001     MOVLW 0x1
01BA  0141     MOVLB 0x1
01BB  02AE     SUBWF i2c_bytes_left, F
01BC  1903     BTFSC STATUS, 0x2
01BD  29BF     GOTO 0x1BF
01BE  29C0     GOTO 0x1C0
01BF  29C8     GOTO 0x1C8
539:                       {
540:           
541:                           /* No, there's more to receive */
542:           
543:                           // No, bit 7 is clear.  Data is ok
544:                           // Set the flag to acknowledge the data
545:                           I2C2_ACKNOWLEDGE_DATA_BIT = 0;
01C0  0143     MOVLB 0x3
01C1  129B     BCF SSP2CON2, 0x5
546:           
547:                           // Wait for the acknowledge to complete, then get more
548:                           i2c2_state = S_MASTER_RCV_DATA;
01C2  3006     MOVLW 0x6
01C3  00F8     MOVWF 0x1F8
01C4  0878     MOVF 0x1F8, W
01C5  0140     MOVLB 0x0
01C6  00D7     MOVWF i2c2_state
549:                       }
01C7  29CD     GOTO 0x1CD
550:                       else
551:                       {
552:           
553:                           // Yes, it's the last byte.  Don't ack it
554:                           // Flag that we will nak the data
555:                           I2C2_ACKNOWLEDGE_DATA_BIT = 1;
01C8  0143     MOVLB 0x3
01C9  169B     BSF SSP2CON2, 0x5
556:           
557:                           I2C2_FunctionComplete();
01CA  318B     MOVLP 0xB
01CB  23C9     CALL 0x3C9
01CC  3180     MOVLP 0x0
558:                       }
559:           
560:                       // Initiate the acknowledge
561:                       I2C2_ACKNOWLEDGE_ENABLE_BIT = 1;
01CD  0143     MOVLB 0x3
01CE  161B     BSF SSP2CON2, 0x4
562:                       break;
01CF  2A03     GOTO 0x203
563:           
564:                   case S_MASTER_RCV_STOP:                
565:                   case S_MASTER_SEND_STOP:
566:           
567:                       // Send the stop flag
568:                       I2C2_Stop(I2C2_MESSAGE_COMPLETE);
01D0  3000     MOVLW 0x0
01D1  318C     MOVLP 0xC
01D2  2405     CALL 0x405
01D3  3180     MOVLP 0x0
569:                       break;
01D4  2A03     GOTO 0x203
570:           
571:                   default:
572:           
573:                       // This case should not happen, if it does then
574:                       // terminate the transfer
575:                       i2c2_object.i2cErrors++;
01D5  3001     MOVLW 0x1
01D6  00F8     MOVWF 0x1F8
01D7  0878     MOVF 0x1F8, W
01D8  0141     MOVLB 0x1
01D9  07A4     ADDWF 0xA4, F
576:                       I2C2_Stop(I2C2_LOST_STATE);
01DA  3006     MOVLW 0x6
01DB  318C     MOVLP 0xC
01DC  2405     CALL 0x405
01DD  3180     MOVLP 0x0
577:                       break;
01DE  2A03     GOTO 0x203
01DF  0140     MOVLB 0x0
01E0  0857     MOVF i2c2_state, W
01E1  3A00     XORLW 0x0
01E2  1903     BTFSC STATUS, 0x2
01E3  289A     GOTO 0x9A
01E4  3A01     XORLW 0x1
01E5  1903     BTFSC STATUS, 0x2
01E6  28D3     GOTO 0xD3
01E7  3A03     XORLW 0x3
01E8  1903     BTFSC STATUS, 0x2
01E9  2925     GOTO 0x125
01EA  3A01     XORLW 0x1
01EB  1903     BTFSC STATUS, 0x2
01EC  2954     GOTO 0x154
01ED  3A07     XORLW 0x7
01EE  1903     BTFSC STATUS, 0x2
01EF  29D0     GOTO 0x1D0
01F0  3A01     XORLW 0x1
01F1  1903     BTFSC STATUS, 0x2
01F2  298D     GOTO 0x18D
01F3  3A03     XORLW 0x3
01F4  1903     BTFSC STATUS, 0x2
01F5  29A5     GOTO 0x1A5
01F6  3A01     XORLW 0x1
01F7  1903     BTFSC STATUS, 0x2
01F8  29D0     GOTO 0x1D0
01F9  3A0F     XORLW 0xF
01FA  1903     BTFSC STATUS, 0x2
01FB  29AC     GOTO 0x1AC
01FC  3A02     XORLW 0x2
01FD  1903     BTFSC STATUS, 0x2
01FE  28D6     GOTO 0xD6
01FF  3A01     XORLW 0x1
0200  1903     BTFSC STATUS, 0x2
0201  28FD     GOTO 0xFD
0202  29D5     GOTO 0x1D5
578:           
579:               }
580:           }
0203  0008     RETURN
581:           
582:           void I2C2_FunctionComplete(void)
583:           {
584:           
585:               // update the trb pointer
586:               p_i2c2_trb_current++;
0BC9  3004     MOVLW 0x4
0BCA  07F0     ADDWF p_i2c2_trb_current, F
0BCB  3000     MOVLW 0x0
0BCC  3DF1     ADDWFC 0x71, F
587:           
588:               // are we done with this string of requests?
589:               if(--i2c2_trb_count == 0)
0BCD  3001     MOVLW 0x1
0BCE  0140     MOVLB 0x0
0BCF  02D6     SUBWF i2c2_trb_count, F
0BD0  1D03     BTFSS STATUS, 0x2
0BD1  2BD3     GOTO 0x3D3
0BD2  2BD4     GOTO 0x3D4
0BD3  2BD9     GOTO 0x3D9
590:               {
591:                   i2c2_state = S_MASTER_SEND_STOP;
0BD4  3004     MOVLW 0x4
0BD5  00F6     MOVWF __pcstackCOMMON
0BD6  0876     MOVF __pcstackCOMMON, W
0BD7  00D7     MOVWF i2c2_state
592:               }
0BD8  2BDB     GOTO 0x3DB
593:               else
594:               {
595:                   i2c2_state = S_MASTER_RESTART;
0BD9  01D7     CLRF i2c2_state
0BDA  0AD7     INCF i2c2_state, F
596:               }
597:           
598:           }
0BDB  0008     RETURN
599:           
600:           void I2C2_Stop(I2C2_MESSAGE_STATUS completion_code)
0C05  00F7     MOVWF i2c_bus_state
601:           {
602:               // then send a stop
603:               I2C2_STOP_CONDITION_ENABLE_BIT = 1;
0C06  0143     MOVLB 0x3
0C07  151B     BSF SSP2CON2, 0x2
604:           
605:               // make sure the flag pointer is not NULL
606:               if (p_i2c2_current->pTrFlag != NULL)
0C08  0140     MOVLB 0x0
0C09  0855     MOVF p_i2c2_current, W
0C0A  3E03     ADDLW 0x3
0C0B  0086     MOVWF FSR1
0C0C  0187     CLRF FSR1H
0C0D  0801     MOVF INDF1, W
0C0E  1903     BTFSC STATUS, 0x2
0C0F  2C11     GOTO 0x411
0C10  2C12     GOTO 0x412
0C11  2C1D     GOTO 0x41D
607:               {
608:                   // update the flag with the completion code
609:                   *(p_i2c2_current->pTrFlag) = completion_code;
0C12  0877     MOVF i2c_bus_state, W
0C13  00F6     MOVWF __pcstackCOMMON
0C14  0855     MOVF p_i2c2_current, W
0C15  3E03     ADDLW 0x3
0C16  0086     MOVWF FSR1
0C17  0187     CLRF FSR1H
0C18  0801     MOVF INDF1, W
0C19  0086     MOVWF FSR1
0C1A  0187     CLRF FSR1H
0C1B  0876     MOVF __pcstackCOMMON, W
0C1C  0081     MOVWF INDF1
610:               }
611:           
612:               // Done, back to idle
613:               i2c2_state = S_MASTER_IDLE;
0C1D  01D7     CLRF i2c2_state
614:               
615:           }
0C1E  0008     RETURN
616:           
617:           void I2C2_MasterWrite(
618:                                           uint8_t *pdata,
619:                                           uint8_t length,
620:                                           uint16_t address,
621:                                           I2C2_MESSAGE_STATUS *pflag)
622:           {
623:               static I2C2_TRANSACTION_REQUEST_BLOCK   trBlock;
624:           
625:               // check if there is space in the queue
626:               if (i2c2_object.trStatus.s.full != true)
627:               {
628:                   I2C2_MasterWriteTRBBuild(&trBlock, pdata, length, address);
629:                   I2C2_MasterTRBInsert(1, &trBlock, pflag);
630:               }
631:               else
632:               {
633:                   *pflag = I2C2_MESSAGE_FAIL;
634:               }
635:           
636:           }
637:           
638:           void I2C2_MasterRead(
639:                                           uint8_t *pdata,
640:                                           uint8_t length,
641:                                           uint16_t address,
642:                                           I2C2_MESSAGE_STATUS *pflag)
643:           {
644:               static I2C2_TRANSACTION_REQUEST_BLOCK   trBlock;
645:           
646:           
647:               // check if there is space in the queue
648:               if (i2c2_object.trStatus.s.full != true)
649:               {
650:                   I2C2_MasterReadTRBBuild(&trBlock, pdata, length, address);
651:                   I2C2_MasterTRBInsert(1, &trBlock, pflag);
652:               }
653:               else
654:               {
655:                   *pflag = I2C2_MESSAGE_FAIL;
656:               }
657:           
658:           }
659:           
660:           
661:           inline void I2C2_WaitForLastPacketToComplete()
662:           {
663:               while(i2c2_state != S_MASTER_IDLE)
664:               {
665:                   // If your code gets stuck here it is because the last packet is never completing
666:                   // Most likely cause is that your interrupt is not firing as it should. Check if you have
667:                   //   correctly enabled all MSSP, Peripheral and GIE interrupt settings.
668:               }
669:           }
670:           
671:           void I2C2_MasterTRBInsert(
672:                                           uint8_t count,
673:                                           I2C2_TRANSACTION_REQUEST_BLOCK *ptrb_list,
674:                                           I2C2_MESSAGE_STATUS *pflag)
675:           {
676:           
677:               // check if there is space in the queue
678:               if (i2c2_object.trStatus.s.full != true)
679:               {
680:                   *pflag = I2C2_MESSAGE_PENDING;
681:           
682:                   i2c2_object.pTrTail->ptrb_list = ptrb_list;
683:                   i2c2_object.pTrTail->count     = count;
684:                   i2c2_object.pTrTail->pTrFlag   = pflag;
685:                   i2c2_object.pTrTail++;
686:           
687:                   // check if the end of the array is reached
688:                   if (i2c2_object.pTrTail == (i2c2_tr_queue + I2C2_CONFIG_TR_QUEUE_LENGTH))
689:                   {
690:                       // adjust to restart at the beginning of the array
691:                       i2c2_object.pTrTail = i2c2_tr_queue;
692:                   }
693:           
694:                   // since we added one item to be processed, we know
695:                   // it is not empty, so set the empty status to false
696:                   i2c2_object.trStatus.s.empty = false;
697:           
698:                   // check if full
699:                   if (i2c2_object.pTrHead == i2c2_object.pTrTail)
700:                   {
701:                       // it is full, set the full status to true
702:                       i2c2_object.trStatus.s.full = true;
703:                   }
704:           
705:               }
706:               else
707:               {
708:                   *pflag = I2C2_MESSAGE_FAIL;
709:               }
710:           
711:               // for interrupt based
712:               if (*pflag == I2C2_MESSAGE_PENDING)
713:               {
714:                   I2C2_WaitForLastPacketToComplete();
715:                   
716:                   // The state machine has to be started manually because it runs only in the ISR.
717:                   // If we called the ISR function here function duplication would double the code size
718:                   //    because this function would be called both from interrupt and from mainline code.
719:                   PIR3bits.SSP2IF = true;
720:           
721:               }   // block until request is complete
722:           
723:           }
724:           
725:           void I2C2_MasterReadTRBBuild(
726:                                           I2C2_TRANSACTION_REQUEST_BLOCK *ptrb,
727:                                           uint8_t *pdata,
728:                                           uint8_t length,
729:                                           uint16_t address)
730:           {
731:               ptrb->address  = address << 1;
732:               // make this a read
733:               ptrb->address |= 0x01;
734:               ptrb->length   = length;
735:               ptrb->pbuffer  = pdata;
736:           }
737:           
738:           void I2C2_MasterWriteTRBBuild(
739:                                           I2C2_TRANSACTION_REQUEST_BLOCK *ptrb,
740:                                           uint8_t *pdata,
741:                                           uint8_t length,
742:                                           uint16_t address)
743:           {
744:               ptrb->address = address << 1;
745:               ptrb->length  = length;
746:               ptrb->pbuffer = pdata;
747:           }
748:           
749:           bool I2C2_MasterQueueIsEmpty(void)
750:           {
751:               return(i2c2_object.trStatus.s.empty);
752:           }
753:           
754:           bool I2C2_MasterQueueIsFull(void)
755:           {
756:               return(i2c2_object.trStatus.s.full);
757:           }        
758:                   
759:           void I2C2_BusCollisionISR( void )
760:           {
761:               // enter bus collision handling code here
762:           	PIR3bits.BCL2IF = 0;
0B37  014E     MOVLB 0xE
0B38  118F     BCF PIR3, 0x3
763:           }        
0B39  0008     RETURN
764:                   
765:                   
766:           /**
767:            End of File
768:           */
---  C:/Users/JonaCappelle/Documents/Github/sensors/firmware/Power_Module/system/i2c1.c  ----------------
1:             /*  ____  ____      _    __  __  ____ ___
2:              * |  _ \|  _ \    / \  |  \/  |/ ___/ _ \
3:              * | | | | |_) |  / _ \ | |\/| | |  | | | |
4:              * | |_| |  _ <  / ___ \| |  | | |__| |_| |
5:              * |____/|_| \_\/_/   \_\_|  |_|\____\___/
6:              *                           research group
7:              *                             dramco.be/
8:              *
9:              *  KU Leuven - Technology Campus Gent,
10:             *  Gebroeders De Smetstraat 1,
11:             *  B-9000 Gent, Belgium
12:             *
13:             *         File: i2c1.c
14:             *      Created: 2020-08-26
15:             *       Author: Geoffrey Ottoy
16:             *      Version: 1.0
17:             *
18:             *  Description: Modified version of the Microchip MSSP1 Driver (see License)
19:             *
20:             */
21:            
22:            /*
23:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
24:                
25:                Subject to your compliance with these terms, you may use Microchip software and any 
26:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
27:                license terms applicable to your use of third party software (including open source software) that 
28:                may accompany Microchip software.
29:                
30:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
31:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
32:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
33:                FOR A PARTICULAR PURPOSE.
34:                
35:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
36:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
37:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
38:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
39:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
40:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
41:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
42:                SOFTWARE.
43:            */
44:            
45:            #include <string.h>
46:            #include "i2c1.h"
47:            #include "../global.h"
48:            
49:            #define I2C1_SLAVE_MASK    0x7F
50:            
51:            #define I2C1_RX_BUF_SIZE   32  // MODIFIED
52:            #define I2C1_TX_BUF_SIZE   32  // MODIFIED
53:            
54:            typedef enum {                 // MODIFIED
55:                SLAVE_COMMAND_DATA,        // MODIFIED
56:                SLAVE_COMMAND,             // MODIFIED
57:            } SLAVE_WRITE_DATA_TYPE;       // MODIFIED
58:            
59:            /**
60:             Section: Global Variables
61:            */
62:            
63:            volatile uint8_t    I2C1_slaveWriteData      = 0x55;
64:            
65:            
66:            // Local variables
67:            static uint8_t i2c1_rx_buffer[I2C1_RX_BUF_SIZE]; // MODIFIED
68:            static uint8_t i2c1_tx_buffer[I2C1_TX_BUF_SIZE]; // MODIFIED
69:            
70:            static uint8_t cmdByte;                          // MODIFIED
71:            static bool cmdReceived;                         // MODIFIED
72:            static uint8_t rxLen;                            // MODIFIED
73:            static uint8_t txLen;                            // MODIFIED
74:            static uint8_t txCnt;                            // MODIFIED
75:            
76:            /**
77:             Section: Local Functions
78:            */
79:            void I2C1_StatusCallback(I2C1_SLAVE_DRIVER_STATUS i2c_bus_state);
80:            
81:            
82:            /**
83:              Prototype:        void I2C1_Initialize(void)
84:              Input:            none
85:              Output:           none
86:              Description:      I2C1_Initialize is an
87:                                initialization routine that takes inputs from the GUI.
88:              Comment:          
89:              Usage:            I2C1_Initialize();
90:            
91:            */
92:            void I2C1_Initialize(uint8_t slave_address){ //MODIFIED
0CE6  0140     MOVLB 0x0
0CE7  00A0     MOVWF __pcstackBANK0
93:                // initialize the hardware
94:                PMD6bits.MSSP1MD = 0; // enable MSSP1
0CE8  014F     MOVLB 0xF
0CE9  101C     BCF PMD6, 0x0
95:                //ANSELB = 0x50;
96:                ANSELBbits.ANSB5 = 0; // RB5 is digital pin
0CEA  017E     MOVLB 0x3E
0CEB  12C3     BCF ANSELB, 0x5
97:                ANSELBbits.ANSB7 = 0; // RB7 is digital pin
0CEC  13C3     BCF ANSELB, 0x7
98:                //TRISB = 0xF0;
99:                TRISBbits.TRISB5 = 1; // RB5 is input
0CED  0140     MOVLB 0x0
0CEE  1693     BSF TRISB, 0x5
100:               TRISBbits.TRISB7 = 1; // RB7 is input
0CEF  1793     BSF TRISB, 0x7
101:               
102:               SSP1CLKPPS = 0x0F;   //RB7->MSSP1:SCL1;    
0CF0  300F     MOVLW 0xF
0CF1  017D     MOVLB 0x3D
0CF2  00C5     MOVWF SSP1CLKPPS
103:               RB7PPS = 0x13;       //RB7->MSSP1:SCL1;    
0CF3  3013     MOVLW 0x13
0CF4  017E     MOVLB 0x3E
0CF5  009F     MOVWF RB7PPS
104:               RB5PPS = 0x14;       //RB5->MSSP1:SDA1;    
0CF6  3014     MOVLW 0x14
0CF7  009D     MOVWF RB5PPS
105:               SSP1DATPPS = 0x0D;   //RB5->MSSP1:SDA1;   
0CF8  300D     MOVLW 0xD
0CF9  017D     MOVLB 0x3D
0CFA  00C6     MOVWF SSP1DATPPS
106:               
107:               // SMP High Speed; CKE disabled; 
108:               SSP1STAT = 0x00;
0CFB  0143     MOVLB 0x3
0CFC  018F     CLRF SSP1STAT
109:               // SSPEN enabled; CKP disabled; SSPM 7 Bit Polling; 
110:               SSP1CON1 = 0x26;
0CFD  3026     MOVLW 0x26
0CFE  0090     MOVWF SSP1CON1
111:               // ACKEN disabled; GCEN disabled; PEN disabled; ACKDT acknowledge; RSEN disabled; RCEN disabled; SEN enabled; 
112:               SSP1CON2 = 0x01;
0CFF  3001     MOVLW 0x1
0D00  0091     MOVWF SSP1CON2
113:               // SBCDE disabled; BOEN disabled; SCIE disabled; PCIE disabled; DHEN disabled; SDAHT 100ns; AHEN disabled; 
114:               SSP1CON3 = 0x00;
0D01  0192     CLRF SSP1CON3
115:               //SSP1CON3bits.AHEN = 1;
116:               SSP1CON3bits.DHEN = 1;
0D02  1412     BSF SSP1CON3, 0x0
117:               // SSPMSK 127; 
118:               SSP1MSK = (I2C1_SLAVE_MASK << 1);  // adjust UI mask for R/nW bit            
0D03  30FE     MOVLW 0xFE
0D04  008E     MOVWF SSP1MSK
119:               // SSPADD; 
120:           	SSP1ADD = (slave_address << 1);  // adjust UI address for R/nW bit //MODIFIED
0D05  0140     MOVLB 0x0
0D06  3520     LSLF __pcstackBANK0, W
0D07  0143     MOVLB 0x3
0D08  008D     MOVWF SSP1ADD
121:           	
122:               
123:               // clear the slave interrupt flag
124:               PIR3bits.SSP1IF = 0;
0D09  014E     MOVLB 0xE
0D0A  100F     BCF PIR3, 0x0
125:               // enable the master interrupt
126:               PIE3bits.SSP1IE = 1;
0D0B  1419     BSF PIE3, 0x0
127:               
128:               txCnt = 0;
0D0C  01F2     CLRF 0x772
129:               rxLen = 0;                  // MODIFIED
0D0D  01F3     CLRF 0x773
130:               cmdReceived = false;        // MODIFIED
0D0E  0141     MOVLB 0x1
0D0F  01B1     CLRF cmdReceived
131:           }
0D10  0008     RETURN
132:           
133:           void I2C1_ISR(void){
134:               uint8_t     i2c_data                = 0x00;
135:           
136:               // NOTE: The slave driver will always acknowledge
137:               //       any address match.
138:           
139:               PIE3bits.SSP1IE = 0;
0E4D  014E     MOVLB 0xE
0E4E  1019     BCF PIE3, 0x0
140:               PIR3bits.SSP1IF = 0;        // clear the slave interrupt flag
0E4F  100F     BCF PIR3, 0x0
141:               i2c_data        = SSP1BUF;  // read SSPBUF to clear BF
0E50  0143     MOVLB 0x3
0E51  080C     MOVF SSP1BUF, W
0E52  00F8     MOVWF 0x1F8
0E53  0878     MOVF 0x1F8, W
0E54  00FA     MOVWF 0x1FA
142:               if(1 == SSP1STATbits.R_nW){
0E55  1D0F     BTFSS SSP1STAT, 0x2
0E56  2E58     GOTO 0x658
0E57  2E59     GOTO 0x659
0E58  2E6D     GOTO 0x66D
143:                   if((1 == SSP1STATbits.D_nA) && (1 == SSP1CON2bits.ACKSTAT)){
0E59  1E8F     BTFSS SSP1STAT, 0x5
0E5A  2E5C     GOTO 0x65C
0E5B  2E5D     GOTO 0x65D
0E5C  2E66     GOTO 0x666
0E5D  1F11     BTFSS SSP1CON2, 0x6
0E5E  2E60     GOTO 0x660
0E5F  2E61     GOTO 0x661
0E60  2E66     GOTO 0x666
144:                       // callback routine can perform any post-read processing
145:                       I2C1_StatusCallback(I2C1_SLAVE_READ_COMPLETED);
0E61  3003     MOVLW 0x3
0E62  3187     MOVLP 0x7
0E63  27A7     CALL 0x7A7
0E64  318E     MOVLP 0xE
146:                   }
0E65  2E95     GOTO 0x695
147:                   else{
148:                       // callback routine should write data into SSPBUF
149:                       I2C1_StatusCallback(I2C1_SLAVE_READ_REQUEST);
0E66  3001     MOVLW 0x1
0E67  3187     MOVLP 0x7
0E68  27A7     CALL 0x7A7
0E69  318E     MOVLP 0xE
150:                       SSP1CON1bits.CKP = 1;       // release SCL
0E6A  0143     MOVLB 0x3
0E6B  1610     BSF SSP1CON1, 0x4
0E6C  2E95     GOTO 0x695
151:                       //while(!PIR3bits.SSP1IF);    // TODO: make non-blocking
152:                   }
153:               }
154:               else if(0 == SSP1STATbits.D_nA){
0E6D  1A8F     BTFSC SSP1STAT, 0x5
0E6E  2E70     GOTO 0x670
0E6F  2E71     GOTO 0x671
0E70  2E76     GOTO 0x676
155:                   // this is an I2C address
156:           
157:                   // callback routine should prepare to receive data from the master
158:                   I2C1_StatusCallback(I2C1_SLAVE_WRITE_REQUEST);
0E71  3000     MOVLW 0x0
0E72  3187     MOVLP 0x7
0E73  27A7     CALL 0x7A7
0E74  318E     MOVLP 0xE
159:               }
0E75  2E95     GOTO 0x695
160:               else{
161:                   I2C1_slaveWriteData   = i2c_data;
0E76  087A     MOVF 0x1FA, W
0E77  00F8     MOVWF 0x1F8
0E78  0878     MOVF 0x1F8, W
0E79  00FC     MOVWF 0x1FC
162:           
163:                   // callback routine should process I2C1_slaveWriteData from the master
164:                   I2C1_StatusCallback(I2C1_SLAVE_WRITE_COMPLETED);
0E7A  3002     MOVLW 0x2
0E7B  3187     MOVLP 0x7
0E7C  27A7     CALL 0x7A7
0E7D  318E     MOVLP 0xE
165:                   SSP1CON1bits.CKP = 1;       // release SCL
0E7E  0143     MOVLB 0x3
0E7F  1610     BSF SSP1CON1, 0x4
166:                   uint8_t ctr=0xff;
0E80  30FF     MOVLW 0xFF
0E81  00F8     MOVWF 0x1F8
0E82  0878     MOVF 0x1F8, W
0E83  00F9     MOVWF 0x1F9
167:                   while(!PIR3bits.SSP1IF && ctr--){
0E84  2E89     GOTO 0x689
168:                       __delay_us(1);
0E85  3200     BRA 0xE86
0E86  3200     BRA 0xE87
0E87  3200     BRA 0xE88
0E88  3200     BRA 0xE89
169:                   }    // TODO: make non-blocking
0E89  014E     MOVLB 0xE
0E8A  180F     BTFSC PIR3, 0x0
0E8B  2E8D     GOTO 0x68D
0E8C  2E8E     GOTO 0x68E
0E8D  2E95     GOTO 0x695
0E8E  3001     MOVLW 0x1
0E8F  02F9     SUBWF 0x779, F
0E90  0A79     INCF 0x779, W
0E91  1D03     BTFSS STATUS, 0x2
0E92  2E94     GOTO 0x694
0E93  2E95     GOTO 0x695
0E94  2E85     GOTO 0x685
170:               }
171:           
172:               // clear the slave interrupt flag
173:               PIR3bits.SSP1IF = 0;
0E95  014E     MOVLB 0xE
0E96  100F     BCF PIR3, 0x0
174:               SSP1CON1bits.CKP    = 1;    // release SCL
0E97  0143     MOVLB 0x3
0E98  1610     BSF SSP1CON1, 0x4
175:           
176:               PIE3bits.SSP1IE = 1;
0E99  014E     MOVLB 0xE
0E9A  1419     BSF PIE3, 0x0
177:           } // end I2C1_ISR()
0E9B  0008     RETURN
178:           
179:           bool I2C1_CommandReceived(void){
180:               return cmdReceived;
0B3A  0141     MOVLB 0x1
0B3B  0831     MOVF cmdReceived, W
181:           }
0B3C  0008     RETURN
182:           
183:           bool I2C1_TxBufferEmpty(void){
184:               return (txCnt != 0);
0B63  0872     MOVF 0xF2, W
0B64  1D03     BTFSS STATUS, 0x2
0B65  2B67     GOTO 0x367
0B66  2B69     GOTO 0x369
0B67  3001     MOVLW 0x1
0B68  2B6A     GOTO 0x36A
0B69  3000     MOVLW 0x0
185:           }
0B6A  0008     RETURN
186:           
187:           void I2C1_GetCommand(uint8_t * cmd){
0BBA  0140     MOVLB 0x0
0BBB  00A1     MOVWF length
188:               *cmd = cmdByte;
0BBC  0141     MOVLB 0x1
0BBD  0832     MOVF cmdByte, W
0BBE  0140     MOVLB 0x0
0BBF  00A0     MOVWF __pcstackBANK0
0BC0  0821     MOVF length, W
0BC1  0086     MOVWF FSR1
0BC2  3001     MOVLW 0x1
0BC3  0087     MOVWF FSR1H
0BC4  0820     MOVF __pcstackBANK0, W
0BC5  0081     MOVWF INDF1
189:               cmdReceived = false;
0BC6  0141     MOVLB 0x1
0BC7  01B1     CLRF cmdReceived
190:           }
0BC8  0008     RETURN
191:           
192:           void I2C1_GetCommandData(uint8_t * data, uint8_t * len){
0C7A  0140     MOVLB 0x0
0C7B  00A2     MOVWF data
193:               memcpy(data, i2c1_rx_buffer, rxLen);
0C7C  0822     MOVF data, W
0C7D  0086     MOVWF FSR1
0C7E  3001     MOVLW 0x1
0C7F  0087     MOVWF FSR1H
0C80  2C90     GOTO 0x490
0C81  3022     MOVLW 0x22
0C82  0084     MOVWF FSR0
0C83  3001     MOVLW 0x1
0C84  0085     MOVWF FSR0H
0C85  0873     MOVF rxLen, W
0C86  0140     MOVLB 0x0
0C87  00A1     MOVWF length
0C88  0821     MOVF length, W
0C89  1903     BTFSC STATUS, 0x2
0C8A  2C91     GOTO 0x491
0C8B  0012     MOVIW FSR0++
0C8C  001E     MOVWI FSR1++
0C8D  0BA1     DECFSZ length, F
0C8E  2C8B     GOTO 0x48B
0C8F  2C91     GOTO 0x491
0C90  2C81     GOTO 0x481
194:               *len = rxLen;
0C91  0873     MOVF rxLen, W
0C92  0140     MOVLB 0x0
0C93  00A1     MOVWF length
0C94  0820     MOVF __pcstackBANK0, W
0C95  0086     MOVWF FSR1
0C96  3001     MOVLW 0x1
0C97  0087     MOVWF FSR1H
0C98  0821     MOVF length, W
0C99  0081     MOVWF INDF1
195:           }
0C9A  0008     RETURN
196:           
197:           void I2C1_SetTransmitData(uint8_t * data, uint8_t len){
0CBC  0140     MOVLB 0x0
0CBD  00A3     MOVWF data
198:               //txCnt = 0;
199:               while((txCnt < len) && (txCnt < I2C1_TX_BUF_SIZE)){
0CBE  2CD3     GOTO 0x4D3
0CD3  0820     MOVF __pcstackBANK0, W
0CD4  0272     SUBWF txCnt, W
0CD5  1803     BTFSC STATUS, 0x0
0CD6  2CD8     GOTO 0x4D8
0CD7  2CD9     GOTO 0x4D9
0CD8  2CDF     GOTO 0x4DF
0CD9  3020     MOVLW 0x20
0CDA  0272     SUBWF txCnt, W
0CDB  1C03     BTFSS STATUS, 0x0
0CDC  2CDE     GOTO 0x4DE
0CDD  2CDF     GOTO 0x4DF
0CDE  2CBF     GOTO 0x4BF
200:                   i2c1_tx_buffer[txCnt] = data[txCnt]; //MODIFIED
0CBF  0872     MOVF txCnt, W
0CC0  0723     ADDWF data, W
0CC1  00A1     MOVWF length
0CC2  0821     MOVF length, W
0CC3  0086     MOVWF FSR1
0CC4  3001     MOVLW 0x1
0CC5  0087     MOVWF FSR1H
0CC6  0801     MOVF INDF1, W
0CC7  00A2     MOVWF data
0CC8  0872     MOVF txCnt, W
0CC9  3EA0     ADDLW 0xA0
0CCA  0086     MOVWF FSR1
0CCB  3001     MOVLW 0x1
0CCC  0087     MOVWF FSR1H
0CCD  0822     MOVF data, W
0CCE  0081     MOVWF INDF1
201:                   txCnt++;
0CCF  3001     MOVLW 0x1
0CD0  00A1     MOVWF length
0CD1  0821     MOVF length, W
0CD2  07F2     ADDWF txCnt, F
202:               }
203:               txLen = txCnt;
0CDF  0872     MOVF txCnt, W
0CE0  00A1     MOVWF length
0CE1  0821     MOVF length, W
0CE2  0141     MOVLB 0x1
0CE3  00B0     MOVWF txLen
204:               txCnt = 0;
0CE4  01F2     CLRF 0xF2
205:           }
0CE5  0008     RETURN
206:           
207:           void I2C1_ClearTxBuffer(void){
208:               txCnt = 0;
209:           }
210:           
211:           /* Implementation of the callback
212:            */
213:           void I2C1_StatusCallback(I2C1_SLAVE_DRIVER_STATUS i2c_bus_state){
07A7  00F7     MOVWF 0xF7
214:           
215:               static uint8_t slaveWriteType   = SLAVE_COMMAND_DATA;
216:           
217:               // actions based on current state
218:               switch (i2c_bus_state){
07A8  2FEB     GOTO 0x7EB
07EB  0877     MOVF 0xF7, W
07EC  3A00     XORLW 0x0
07ED  1903     BTFSC STATUS, 0x2
07EE  2FA9     GOTO 0x7A9
07EF  3A01     XORLW 0x1
07F0  1903     BTFSC STATUS, 0x2
07F1  2FD4     GOTO 0x7D4
07F2  3A03     XORLW 0x3
07F3  1903     BTFSC STATUS, 0x2
07F4  2FC9     GOTO 0x7C9
07F5  3A01     XORLW 0x1
07F6  1903     BTFSC STATUS, 0x2
07F7  2FF9     GOTO 0x7F9
07F8  2FF9     GOTO 0x7F9
219:                   
220:                   case I2C1_SLAVE_WRITE_REQUEST:
221:                       // the master will be sending the eeprom address next
222:                       slaveWriteType  = SLAVE_COMMAND;
07A9  0141     MOVLB 0x1
07AA  01AF     CLRF slaveWriteType
07AB  0AAF     INCF slaveWriteType, F
223:                       break;
07AC  2FF9     GOTO 0x7F9
224:           
225:                   case I2C1_SLAVE_WRITE_COMPLETED:
226:           
227:                       switch(slaveWriteType)
07C9  0141     MOVLB 0x1
07CA  082F     MOVF slaveWriteType, W
07CB  3A00     XORLW 0x0
07CC  1903     BTFSC STATUS, 0x2
07CD  2FB5     GOTO 0x7B5
07CE  3A01     XORLW 0x1
07CF  1903     BTFSC STATUS, 0x2
07D0  2FAD     GOTO 0x7AD
07D1  2FB5     GOTO 0x7B5
228:                       {
229:                           case SLAVE_COMMAND:
230:                               cmdByte   = I2C1_slaveWriteData;
07AD  087C     MOVF 0xFC, W
07AE  00F6     MOVWF 0xF6
07AF  0876     MOVF 0xF6, W
07B0  00B2     MOVWF cmdByte
231:                               rxLen = 0;
07B1  01F3     CLRF 0xF3
232:                               cmdReceived = true;
07B2  01B1     CLRF cmdReceived
07B3  0AB1     INCF cmdReceived, F
233:                               break;
07B4  2FD2     GOTO 0x7D2
234:           
235:                           case SLAVE_COMMAND_DATA:
236:                           default:
237:                               // the master has written data to store in the eeprom
238:                               if(rxLen <= I2C1_RX_BUF_SIZE)
07B5  3021     MOVLW 0x21
07B6  0273     SUBWF 0xF3, W
07B7  1803     BTFSC STATUS, 0x0
07B8  2FBA     GOTO 0x7BA
07B9  2FBB     GOTO 0x7BB
07BA  2FD2     GOTO 0x7D2
239:                               {
240:                                   i2c1_rx_buffer[rxLen++]    = I2C1_slaveWriteData;
07BB  087C     MOVF 0xFC, W
07BC  00F6     MOVWF 0xF6
07BD  0873     MOVF 0xF3, W
07BE  3E22     ADDLW 0x22
07BF  0086     MOVWF FSR1L
07C0  3001     MOVLW 0x1
07C1  0087     MOVWF FSR1H
07C2  0876     MOVF 0xF6, W
07C3  0081     MOVWF INDF1
07C4  3001     MOVLW 0x1
07C5  00F6     MOVWF 0xF6
07C6  0876     MOVF 0xF6, W
07C7  07F3     ADDWF 0xF3, F
07C8  2FD2     GOTO 0x7D2
241:                               }
242:                               break;
243:           
244:                       } // end switch(slaveWriteType)
245:           
246:                       slaveWriteType  = SLAVE_COMMAND_DATA;
07D2  01AF     CLRF slaveWriteType
247:                       break;
07D3  2FF9     GOTO 0x7F9
248:           
249:                   case I2C1_SLAVE_READ_REQUEST:
250:                       if(txCnt<txLen){
07D4  0141     MOVLB 0x1
07D5  0830     MOVF txLen, W
07D6  0272     SUBWF 0xF2, W
07D7  1803     BTFSC STATUS, 0x0
07D8  2FDA     GOTO 0x7DA
07D9  2FDB     GOTO 0x7DB
07DA  2FE8     GOTO 0x7E8
251:                           SSP1BUF = i2c1_tx_buffer[txCnt++];
07DB  0872     MOVF 0xF2, W
07DC  3EA0     ADDLW 0xA0
07DD  0086     MOVWF FSR1L
07DE  3001     MOVLW 0x1
07DF  0087     MOVWF FSR1H
07E0  0801     MOVF INDF1, W
07E1  0143     MOVLB 0x3
07E2  008C     MOVWF SSP1BUF
07E3  3001     MOVLW 0x1
07E4  00F6     MOVWF 0x1F6
07E5  0876     MOVF 0x1F6, W
07E6  07F2     ADDWF 0x1F2, F
252:                       }
07E7  2FF9     GOTO 0x7F9
253:                       else{
254:                           SSP1BUF = 0x00;
07E8  0143     MOVLB 0x3
07E9  018C     CLRF SSP1BUF
07EA  2FF9     GOTO 0x7F9
07EB  0877     MOVF 0x1F7, W
07EC  3A00     XORLW 0x0
07ED  1903     BTFSC STATUS, 0x2
07EE  2FA9     GOTO 0x7A9
07EF  3A01     XORLW 0x1
07F0  1903     BTFSC STATUS, 0x2
07F1  2FD4     GOTO 0x7D4
07F2  3A03     XORLW 0x3
07F3  1903     BTFSC STATUS, 0x2
07F4  2FC9     GOTO 0x7C9
07F5  3A01     XORLW 0x1
07F6  1903     BTFSC STATUS, 0x2
07F7  2FF9     GOTO 0x7F9
07F8  2FF9     GOTO 0x7F9
255:                       }
256:           //            SSP1CON1bits.CKP = 1;
257:                       break;
258:           
259:                   case I2C1_SLAVE_READ_COMPLETED:
260:                   default:;
261:           
262:               } // end switch(i2c_bus_state)
263:           }
07F9  0008     RETURN
264:           
---  C:/Users/JonaCappelle/Documents/Github/sensors/firmware/Power_Module/system/adcc.c  ----------------
1:             /**
2:               ADCC Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 adcc.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the ADCC driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides implementations for driver APIs for ADCC.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC16F18446
18:                    Driver Version    :  2.1.4
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above
21:                    MPLAB             :  MPLAB X 5.20
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "adcc.h"
53:            //#include "mcc.h"
54:            //#include "../Sensors/sound_level.h"
55:            //Dummy.h"
56:            
57:            /**
58:              Section: ADCC Module Variables
59:            */
60:            void (*ADCC_ADI_InterruptHandler)(void);
61:            
62:            /**
63:              Section: ADCC Module APIs
64:            */
65:            
66:            void ADCC_Initialize(void)
67:            {
68:                // set the ADCC to the options selected in the User Interface
69:                // ADLTH 0; 
70:                ADLTHL = 0x00;
71:                // ADLTH 0; 
72:                ADLTHH = 0x00;
73:                // ADUTH 0; 
74:                ADUTHL = 0x00;
75:                // ADUTH 0; 
76:                ADUTHH = 0x00;
77:                // ADSTPT 0; 
78:                ADSTPTL = 0x00;
79:                // ADSTPT 0; 
80:                ADSTPTH = 0x00;
81:                // ADACC 0; 
82:                ADACCU = 0x00;
83:                // ADRPT 0; 
84:                ADRPT = 0x00;
85:                // ADPCH ANA0; 
86:                ADPCH = 0x00;
87:                // ADACQ 0; 
88:                ADACQL = 0x00;
89:                // ADACQ 0; 
90:                ADACQH = 0x00;
91:                // ADCAP Additional uC disabled; 
92:                ADCAP = 0x00;
93:                // ADPRE 0; 
94:                ADPREL = 0x00;
95:                // ADPRE 0; 
96:                ADPREH = 0x00;
97:                // ADDSEN disabled; ADGPOL digital_low; ADIPEN disabled; ADPPOL Vss; 
98:                ADCON1 = 0x00;
99:                // ADCRS 0; ADMD Basic_mode; ADACLR disabled; ADPSIS RES; 
100:               ADCON2 = 0x00;
101:               // ADCALC First derivative of Single measurement; ADTMD disabled; ADSOI ADGO not cleared; 
102:               ADCON3 = 0x00;
103:               // ADMATH registers not updated; 
104:               ADSTAT = 0x00;
105:               // ADNREF VSS; ADPREF VDD; 
106:               ADREF = 0x00;
107:               // ADACT disabled; 
108:               ADACT = 0x00;
109:               // ADCS FOSC/128; 
110:               ADCLK = 0x3F;
111:               // ADGO stop; ADFM right; ADON enabled; ADCS FOSC/ADCLK; ADCONT disabled; 
112:               ADCON0 = 0x84;
113:               
114:               // Clear the ADC interrupt flag
115:               PIR1bits.ADIF = 0;
116:               // Enabling ADCC interrupt.
117:               PIE1bits.ADIE = 1;
118:           
119:               ADCC_SetADIInterruptHandler(ADCC_DefaultInterruptHandler);
120:           
121:           }
122:           
123:           void ADCC_StartConversion(adcc_channel_t channel)
124:           {
125:               // select the A/D channel
126:               ADPCH = channel;      
127:             
128:               // Turn on the ADC module
129:               ADCON0bits.ADON = 1;
130:           
131:               // Start the conversion
132:               ADCON0bits.ADGO = 1;
133:           }
134:           
135:           bool ADCC_IsConversionDone()
136:           {
137:               // Start the conversion
138:               return ((unsigned char)(!ADCON0bits.ADGO));
139:           }
140:           
141:           adc_result_t ADCC_GetConversionResult(void)
142:           {
143:               // Return the result
144:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
145:           }
146:           
147:           adc_result_t ADCC_GetSingleConversion(adcc_channel_t channel)
148:           {
149:               // select the A/D channel
150:               ADPCH = channel;  
151:           
152:               // Turn on the ADC module
153:               ADCON0bits.ADON = 1;
154:           	
155:               //Disable the continuous mode.
156:               ADCON0bits.ADCONT = 0;    
157:           
158:               // Start the conversion
159:               ADCON0bits.ADGO = 1;
160:           
161:           
162:               // Wait for the conversion to finish
163:               while (ADCON0bits.ADGO)
164:               {
165:               }
166:               
167:               
168:               // Conversion finished, return the result
169:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
170:           }
171:           
172:           void ADCC_StopConversion(void)
173:           {
174:               //Reset the ADGO bit.
175:               ADCON0bits.ADGO = 0;
176:           }
177:           
178:           void ADCC_SetStopOnInterrupt(void)
179:           {
180:               //Set the ADSOI bit.
181:               ADCON3bits.ADSOI = 1;
182:           }
183:           
184:           void ADCC_DischargeSampleCapacitor(void)
185:           {
186:               //Set the ADC channel to AVss.
187:               ADPCH = 0x3b;   
188:           }
189:           
190:           void ADCC_LoadAcquisitionRegister(uint16_t acquisitionValue)
191:           {
192:               //Load the ADACQH and ADACQL registers.
193:               ADACQH = acquisitionValue >> 8; 
194:               ADACQL = acquisitionValue;  
195:           }
196:           
197:           void ADCC_SetPrechargeTime(uint16_t prechargeTime)
198:           {
199:               //Load the ADPREH and ADPREL registers.
200:               ADPREH = prechargeTime >> 8;  
201:               ADPREL = prechargeTime;
202:           }
203:           
204:           void ADCC_SetRepeatCount(uint8_t repeatCount)
205:           {
206:               //Load the ADRPT register.
207:               ADRPT = repeatCount;   
208:           }
209:           
210:           uint8_t ADCC_GetCurrentCountofConversions(void)
211:           {
212:               //Return the contents of ADCNT register
213:               return ADCNT;
214:           }
215:           
216:           void ADCC_ClearAccumulator(void)
217:           {
218:               //Reset the ADCON2bits.ADACLR bit.
219:               ADCON2bits.ADACLR = 1;
220:           }
221:           
222:           uint24_t ADCC_GetAccumulatorValue(void)
223:           {
224:               //Return the contents of ADACCU, ADACCH and ADACCL registers
225:               return (((uint24_t)ADACCU << 16)+((uint24_t)ADACCH << 8) + ADACCL);
226:           }
227:           
228:           bool ADCC_HasAccumulatorOverflowed(void)
229:           {
230:               //Return the status of ADSTATbits.ADAOV
231:               return ADSTATbits.ADAOV;
232:           }
233:           
234:           uint16_t ADCC_GetFilterValue(void)
235:           {
236:               //Return the contents of ADFLTRH and ADFLTRL registers
237:               return ((uint16_t)((ADFLTRH << 8) + ADFLTRL));
238:           }
239:           
240:           uint16_t ADCC_GetPreviousResult(void)
241:           {
242:               //Return the contents of ADPREVH and ADPREVL registers
243:               return ((uint16_t)((ADPREVH << 8) + ADPREVL));
244:           }
245:           
246:           void ADCC_DefineSetPoint(uint16_t setPoint)
247:           {
248:               //Sets the ADSTPTH and ADSTPTL registers
249:               ADSTPTH = setPoint >> 8;
250:               ADSTPTL = setPoint;
251:           }
252:           
253:           void ADCC_SetUpperThreshold(uint16_t upperThreshold)
254:           {
255:               //Sets the ADUTHH and ADUTHL registers
256:               ADUTHH = upperThreshold >> 8;
257:               ADUTHL = upperThreshold;
258:           }
259:           
260:           void ADCC_SetLowerThreshold(uint16_t lowerThreshold)
261:           {
262:               //Sets the ADLTHH and ADLTHL registers
263:               ADLTHH = lowerThreshold >> 8;
264:               ADLTHL = lowerThreshold;
265:           }
266:           
267:           uint16_t ADCC_GetErrorCalculation(void)
268:           {
269:           	//Return the contents of ADERRH and ADERRL registers
270:           	return ((uint16_t)((ADERRH << 8) + ADERRL));
271:           }
272:           
273:           void ADCC_EnableDoubleSampling(void)
274:           {
275:               //Sets the ADCON1bits.ADDSEN
276:               ADCON1bits.ADDSEN = 1;
277:           }
278:           
279:           void ADCC_EnableContinuousConversion(void)
280:           {
281:               //Sets the ADCON0bits.ADCONT
282:               ADCON0bits.ADCONT = 1;
283:           }
284:           
285:           void ADCC_DisableContinuousConversion(void)
286:           {
287:               //Resets the ADCON0bits.ADCONT
288:               ADCON0bits.ADCONT = 0;
289:           }
290:           
291:           bool ADCC_HasErrorCrossedUpperThreshold(void)
292:           {
293:               //Returns the value of ADSTATbits.ADUTHR bit.
294:               return ADSTATbits.ADUTHR;
295:           }
296:           
297:           bool ADCC_HasErrorCrossedLowerThreshold(void)
298:           {
299:               //Returns the value of ADSTATbits.ADLTHR bit.
300:               return ADSTATbits.ADLTHR;
301:           }
302:           
303:           uint8_t ADCC_GetConversionStageStatus(void)
304:           {
305:               //Returns the contents of ADSTATbits.ADSTAT field.
306:               return ADSTATbits.ADSTAT;
307:           }
308:           
309:           void ADCC_ISR(void){   
310:               //getValue();
311:               // Clear the ADCC interrupt flag
312:               PIR1bits.ADIF = 0;
0BAB  014E     MOVLB 0xE
0BAC  100D     BCF PIR1, 0x0
313:           
314:               if (ADCC_ADI_InterruptHandler)
0BAD  0141     MOVLB 0x1
0BAE  082B     MOVF ADCC_ADI_InterruptHandler, W
0BAF  042C     IORWF 0xAC, W
0BB0  1903     BTFSC STATUS, 0x2
0BB1  2BB3     GOTO 0x3B3
0BB2  2BB4     GOTO 0x3B4
0BB3  2BB9     GOTO 0x3B9
315:                       ADCC_ADI_InterruptHandler();
0BB4  082C     MOVF 0xAC, W
0BB5  008A     MOVWF PCLATH
0BB6  082B     MOVF ADCC_ADI_InterruptHandler, W
0BB7  000A     CALLW
0BB8  318B     MOVLP 0xB
316:           }
0BB9  0008     RETURN
317:           
318:           void ADCC_SetADIInterruptHandler(void (* InterruptHandler)(void)){
319:               ADCC_ADI_InterruptHandler = InterruptHandler;
320:           }
321:           
322:           void ADCC_DefaultInterruptHandler(void){
323:               // add your ADCC interrupt custom code
324:               // or set custom function using ADCC_SetADIInterruptHandler() or ADCC_SetADTIInterruptHandler()
325:           }
0B34  0008     RETURN
326:           /**
327:            End of File
328:           */
---  C:/Users/JonaCappelle/Documents/Github/sensors/firmware/Power_Module/sensor/util.c  ----------------
1:             /*  ____  ____      _    __  __  ____ ___
2:              * |  _ \|  _ \    / \  |  \/  |/ ___/ _ \
3:              * | | | | |_) |  / _ \ | |\/| | |  | | | |
4:              * | |_| |  _ <  / ___ \| |  | | |__| |_| |
5:              * |____/|_| \_\/_/   \_\_|  |_|\____\___/
6:              *                           research group
7:              *                             dramco.be/
8:              *
9:              *  KU Leuven - Technology Campus Gent,
10:             *  Gebroeders De Smetstraat 1,
11:             *  B-9000 Gent, Belgium
12:             *
13:             *         File: util.c
14:             *      Created: 2020-11-27
15:             *       Author: Jona Cappelle
16:             *      Version: 0.2
17:             *
18:             *  Description: Utilities - LEDS - Interrupt pin
19:             *
20:             */
21:            
22:            #include "util.h"
23:            
24:            
25:            void LED_Init(void)
26:            {
27:                LED0_SetDigitalMode();
0B8F  017E     MOVLB 0x3E
0B90  13CE     BCF ANSELC, 0x7
28:                LED0_SetDigitalOutput();
0B91  0140     MOVLB 0x0
0B92  1394     BCF TRISC, 0x7
29:                LED0_SetLow();
0B93  139A     BCF LATC, 0x7
30:                
31:                LED1_SetDigitalOutput();
0B94  1314     BCF TRISC, 0x6
32:                LED1_SetDigitalMode();
0B95  017E     MOVLB 0x3E
0B96  134E     BCF ANSELC, 0x6
33:                LED1_SetLow();
0B97  0140     MOVLB 0x0
0B98  131A     BCF LATC, 0x6
34:                
35:                /* Blink LED */
36:                LED_Blink();  
0B99  3186     MOVLP 0x6
0B9A  2684     CALL 0x684
0B9B  318B     MOVLP 0xB
37:            }
0B9C  0008     RETURN
38:            
39:            /* Animation when Sound Module is plugged in */
40:            void LED_Blink(void)
41:            {
42:                // startup animation
43:                LED0_SetHigh();
0684  0140     MOVLB 0x0
0685  179A     BSF LATC, 0x7
44:                __delay_ms(100);
0686  3005     MOVLW 0x5
0687  0140     MOVLB 0x0
0688  00A1     MOVWF length
0689  300F     MOVLW 0xF
068A  00A0     MOVWF __pcstackBANK0
068B  30F1     MOVLW 0xF1
068C  0B89     DECFSZ WREG, F
068D  2E8C     GOTO 0x68C
068E  0BA0     DECFSZ __pcstackBANK0, F
068F  2E8C     GOTO 0x68C
0690  0BA1     DECFSZ length, F
0691  2E8C     GOTO 0x68C
45:                LED0_SetLow();
0692  0140     MOVLB 0x0
0693  139A     BCF LATC, 0x7
46:                __delay_ms(100);
0694  3005     MOVLW 0x5
0695  0140     MOVLB 0x0
0696  00A1     MOVWF length
0697  300F     MOVLW 0xF
0698  00A0     MOVWF __pcstackBANK0
0699  30F1     MOVLW 0xF1
069A  0B89     DECFSZ WREG, F
069B  2E9A     GOTO 0x69A
069C  0BA0     DECFSZ __pcstackBANK0, F
069D  2E9A     GOTO 0x69A
069E  0BA1     DECFSZ length, F
069F  2E9A     GOTO 0x69A
47:                LED0_SetHigh();
06A0  0140     MOVLB 0x0
06A1  179A     BSF LATC, 0x7
48:                __delay_ms(100);
06A2  3005     MOVLW 0x5
06A3  0140     MOVLB 0x0
06A4  00A1     MOVWF length
06A5  300F     MOVLW 0xF
06A6  00A0     MOVWF __pcstackBANK0
06A7  30F1     MOVLW 0xF1
06A8  0B89     DECFSZ WREG, F
06A9  2EA8     GOTO 0x6A8
06AA  0BA0     DECFSZ __pcstackBANK0, F
06AB  2EA8     GOTO 0x6A8
06AC  0BA1     DECFSZ length, F
06AD  2EA8     GOTO 0x6A8
49:                LED0_SetLow();
06AE  0140     MOVLB 0x0
06AF  139A     BCF LATC, 0x7
50:                __delay_ms(100);
06B0  3005     MOVLW 0x5
06B1  0140     MOVLB 0x0
06B2  00A1     MOVWF length
06B3  300F     MOVLW 0xF
06B4  00A0     MOVWF __pcstackBANK0
06B5  30F1     MOVLW 0xF1
06B6  0B89     DECFSZ WREG, F
06B7  2EB6     GOTO 0x6B6
06B8  0BA0     DECFSZ __pcstackBANK0, F
06B9  2EB6     GOTO 0x6B6
06BA  0BA1     DECFSZ length, F
06BB  2EB6     GOTO 0x6B6
51:                LED0_SetHigh();
06BC  0140     MOVLB 0x0
06BD  179A     BSF LATC, 0x7
52:                __delay_ms(100);
06BE  3005     MOVLW 0x5
06BF  0140     MOVLB 0x0
06C0  00A1     MOVWF length
06C1  300F     MOVLW 0xF
06C2  00A0     MOVWF __pcstackBANK0
06C3  30F1     MOVLW 0xF1
06C4  0B89     DECFSZ WREG, F
06C5  2EC4     GOTO 0x6C4
06C6  0BA0     DECFSZ __pcstackBANK0, F
06C7  2EC4     GOTO 0x6C4
06C8  0BA1     DECFSZ length, F
06C9  2EC4     GOTO 0x6C4
53:                LED0_SetLow();
06CA  0140     MOVLB 0x0
06CB  139A     BCF LATC, 0x7
54:                __delay_ms(500);
06CC  3015     MOVLW 0x15
06CD  0140     MOVLB 0x0
06CE  00A1     MOVWF length
06CF  304B     MOVLW 0x4B
06D0  00A0     MOVWF __pcstackBANK0
06D1  30BE     MOVLW 0xBE
06D2  0B89     DECFSZ WREG, F
06D3  2ED2     GOTO 0x6D2
06D4  0BA0     DECFSZ __pcstackBANK0, F
06D5  2ED2     GOTO 0x6D2
06D6  0BA1     DECFSZ length, F
06D7  2ED2     GOTO 0x6D2
06D8  0000     NOP
55:                
56:                LED1_SetHigh();
06D9  0140     MOVLB 0x0
06DA  171A     BSF LATC, 0x6
57:                __delay_ms(100);
06DB  3005     MOVLW 0x5
06DC  0140     MOVLB 0x0
06DD  00A1     MOVWF length
06DE  300F     MOVLW 0xF
06DF  00A0     MOVWF __pcstackBANK0
06E0  30F1     MOVLW 0xF1
06E1  0B89     DECFSZ WREG, F
06E2  2EE1     GOTO 0x6E1
06E3  0BA0     DECFSZ __pcstackBANK0, F
06E4  2EE1     GOTO 0x6E1
06E5  0BA1     DECFSZ length, F
06E6  2EE1     GOTO 0x6E1
58:                LED1_SetLow();
06E7  0140     MOVLB 0x0
06E8  131A     BCF LATC, 0x6
59:                __delay_ms(100);
06E9  3005     MOVLW 0x5
06EA  0140     MOVLB 0x0
06EB  00A1     MOVWF length
06EC  300F     MOVLW 0xF
06ED  00A0     MOVWF __pcstackBANK0
06EE  30F1     MOVLW 0xF1
06EF  0B89     DECFSZ WREG, F
06F0  2EEF     GOTO 0x6EF
06F1  0BA0     DECFSZ __pcstackBANK0, F
06F2  2EEF     GOTO 0x6EF
06F3  0BA1     DECFSZ length, F
06F4  2EEF     GOTO 0x6EF
60:                LED1_SetHigh();
06F5  0140     MOVLB 0x0
06F6  171A     BSF LATC, 0x6
61:                __delay_ms(100);
06F7  3005     MOVLW 0x5
06F8  0140     MOVLB 0x0
06F9  00A1     MOVWF length
06FA  300F     MOVLW 0xF
06FB  00A0     MOVWF __pcstackBANK0
06FC  30F1     MOVLW 0xF1
06FD  0B89     DECFSZ WREG, F
06FE  2EFD     GOTO 0x6FD
06FF  0BA0     DECFSZ __pcstackBANK0, F
0700  2EFD     GOTO 0x6FD
0701  0BA1     DECFSZ length, F
0702  2EFD     GOTO 0x6FD
62:                LED1_SetLow();
0703  0140     MOVLB 0x0
0704  131A     BCF LATC, 0x6
63:                __delay_ms(100);
0705  3005     MOVLW 0x5
0706  0140     MOVLB 0x0
0707  00A1     MOVWF length
0708  300F     MOVLW 0xF
0709  00A0     MOVWF __pcstackBANK0
070A  30F1     MOVLW 0xF1
070B  0B89     DECFSZ WREG, F
070C  2F0B     GOTO 0x70B
070D  0BA0     DECFSZ __pcstackBANK0, F
070E  2F0B     GOTO 0x70B
070F  0BA1     DECFSZ length, F
0710  2F0B     GOTO 0x70B
64:                LED1_SetHigh();
0711  0140     MOVLB 0x0
0712  171A     BSF LATC, 0x6
65:                __delay_ms(100);
0713  3005     MOVLW 0x5
0714  0140     MOVLB 0x0
0715  00A1     MOVWF length
0716  300F     MOVLW 0xF
0717  00A0     MOVWF __pcstackBANK0
0718  30F1     MOVLW 0xF1
0719  0B89     DECFSZ WREG, F
071A  2F19     GOTO 0x719
071B  0BA0     DECFSZ __pcstackBANK0, F
071C  2F19     GOTO 0x719
071D  0BA1     DECFSZ length, F
071E  2F19     GOTO 0x719
66:                LED1_SetLow();
071F  0140     MOVLB 0x0
0720  131A     BCF LATC, 0x6
67:            }
0721  0008     RETURN
68:            
69:            void comm_init(void)
70:            {
71:                READY_SetDigitalMode();
0B43  017E     MOVLB 0x3E
0B44  104E     BCF ANSELC, 0x0
72:                READY_SetDigitalOutput();
0B45  0140     MOVLB 0x0
0B46  1014     BCF TRISC, 0x0
73:                READY_SetHigh();
0B47  141A     BSF LATC, 0x0
74:            }
0B48  0008     RETURN
75:            
76:            void generateInt(void){
77:                READY_SetLow();
0B9D  0140     MOVLB 0x0
0B9E  101A     BCF LATC, 0x0
78:                __delay_ms(1);                          
0B9F  300B     MOVLW 0xB
0BA0  0140     MOVLB 0x0
0BA1  00A0     MOVWF __pcstackBANK0
0BA2  3062     MOVLW 0x62
0BA3  0B89     DECFSZ WREG, F
0BA4  2BA3     GOTO 0x3A3
0BA5  0BA0     DECFSZ __pcstackBANK0, F
0BA6  2BA3     GOTO 0x3A3
0BA7  0000     NOP
79:                READY_SetHigh();
0BA8  0140     MOVLB 0x0
0BA9  141A     BSF LATC, 0x0
80:            }
0BAA  0008     RETURN
---  C:/Users/JonaCappelle/Documents/Github/sensors/firmware/Power_Module/sensor/power.c  ---------------
1:             /*  ____  ____      _    __  __  ____ ___
2:              * |  _ \|  _ \    / \  |  \/  |/ ___/ _ \
3:              * | | | | |_) |  / _ \ | |\/| | |  | | | |
4:              * | |_| |  _ <  / ___ \| |  | | |__| |_| |
5:              * |____/|_| \_\/_/   \_\_|  |_|\____\___/
6:              *                           research group
7:              *                             dramco.be/
8:              *
9:              *  KU Leuven - Technology Campus Gent,
10:             *  Gebroeders De Smetstraat 1,
11:             *  B-9000 Gent, Belgium
12:             *
13:             *         File: power.c
14:             *      Created: 2020-11-27
15:             *       Author: Jona Cappelle
16:             *      Version: 0.2
17:             *
18:             *  Description: Power Module Implementation
19:             *
20:             */
21:            
22:            #include "power.h"
23:            #include <math.h>
24:            #include "string.h"
25:            #include "../system/adcc.h"
26:            
27:            
28:            #ifdef SENSOR_TYPE
29:            #if (SENSOR_TYPE == POWER)
30:            #warning "Compiling for Power sensor"
31:            #include "veml7700.h"
32:            #include "battery.h"
33:            #include "util.h"
34:            
35:            /*===================================*/
36:            // Declaration global power struct
37:            volatile iwast_power_t power;
38:            // Sensor settings
39:            //veml7700_settings veml7700_config;
40:            /*===================================*/
41:            
42:            /* Variables */
43:            volatile uint8_t measurementData[2* M_NR];
44:            
45:            void POWER_init_params()
46:            {
47:                // Initialize struct to all zeros
48:                memset(&power, 0, sizeof(power));
0B75  3000     MOVLW 0x0
0B76  0140     MOVLB 0x0
0B77  00A0     MOVWF __pcstackBANK0
0B78  00A1     MOVWF length
0B79  301C     MOVLW 0x1C
0B7A  00A2     MOVWF data
0B7B  3000     MOVLW 0x0
0B7C  00A3     MOVWF data
0B7D  30B3     MOVLW 0xB3
0B7E  318C     MOVLP 0xC
0B7F  243C     CALL 0x43C
0B80  318B     MOVLP 0xB
49:            }
0B81  0008     RETURN
50:            
51:            void WDT_Init(void)
52:            {
53:                // initialize timer for periodic measurements   
54:            //    WDTCON0 = 0x1C; // 16 second period
55:                WDTCON0 = 0x20; // 64 second period    
0B3D  3020     MOVLW 0x20
0B3E  0150     MOVLB 0x10
0B3F  008C     MOVWF WDTCON0
56:                WDTCON1 = 0x07; // LFINTOSC, window 100%
0B40  3007     MOVLW 0x7
0B41  008D     MOVWF WDTCON1
57:            }
0B42  0008     RETURN
58:            
59:            void Enter_sleep(){
60:                /* Go to sleep */
61:                CPUDOZEbits.IDLEN = 0; // make sure PIC is not in doze mode before going to sleep   
0B55  0151     MOVLB 0x11
0B56  138C     BCF CPUDOZE, 0x7
62:                NOP();
0B57  0000     NOP
63:                SLEEP(); // enter sleep
0B58  0063     SLEEP
64:                NOP();
0B59  0000     NOP
65:                NOP();
0B5A  0000     NOP
66:            }
0B5B  0008     RETURN
67:            
68:            void Power_Init(){
69:                
70:                PMD0bits.IOCMD = 0; // Enable gpio clock
0C1F  014F     MOVLB 0xF
0C20  1016     BCF PMD0, 0x0
71:                
72:                // Init needed variables
73:                POWER_init_params();
0C21  318B     MOVLP 0xB
0C22  2375     CALL 0x375
0C23  318C     MOVLP 0xC
74:            
75:                // Set settings - with these setting, the sensor should consume about 2 uA
76:            //    veml7700_config.threshold_high = 0;
77:            //    veml7700_config.threshold_low = 0;
78:            //    veml7700_config.gain = VEML7700_GAIN_X1;
79:            //    veml7700_config.integration_time = VEML7700_INTEGRATION_TIME_100MS;
80:            //    veml7700_config.persistence = VEML7700_PERSISTENCE_1;
81:            //    veml7700_config.interrupts = VEML7700_INTERRUPT_ENABLE;
82:            //    veml7700_config.powersave_en = VEML7700_PS_ENABLE;
83:            //    veml7700_config.powersave = VEML7700_PS_MODE4;
84:            //    veml7700_config.shutdown = VEML7700_POWER_ON;
85:                
86:                // Light sensor
87:            //    veml7700_power(VEML7700_POWER_ENABLE);
88:                // Init Light Sensor
89:            //    veml7700_init(&veml7700_config, &power.meas.light.data);  
90:                power.meas.light.data.lux = 1000;
0C24  3000     MOVLW 0x0
0C25  0141     MOVLB 0x1
0C26  00B8     MOVWF 0xB8
0C27  307A     MOVLW 0x7A
0C28  00B9     MOVWF 0xB9
0C29  3044     MOVLW 0x44
0C2A  00BA     MOVWF 0xBA
91:                
92:                // Ready pin to motherboard
93:                comm_init();
0C2B  318B     MOVLP 0xB
0C2C  2343     CALL 0x343
0C2D  318C     MOVLP 0xC
94:                
95:                // Init LEDS
96:                LED_Init();
0C2E  318B     MOVLP 0xB
0C2F  238F     CALL 0x38F
0C30  318C     MOVLP 0xC
97:                
98:                // Init battery measurements
99:            //    battery_init();
100:           //    power.meas.batt.voltage = battery_measure(); // Initial measurement
101:               power.meas.batt.voltage = 4.0;
0C31  3000     MOVLW 0x0
0C32  0141     MOVLB 0x1
0C33  00B3     MOVWF power
0C34  3080     MOVLW 0x80
0C35  00B4     MOVWF 0xB4
0C36  3040     MOVLW 0x40
0C37  00B5     MOVWF 0xB5
102:               
103:               // Init Watchdog
104:               WDT_Init();  
0C38  318B     MOVLP 0xB
0C39  233D     CALL 0x33D
0C3A  318C     MOVLP 0xC
105:           }
0C3B  0008     RETURN
106:           
107:           void Power_Measure(){
108:               power.ctrl.startMeasurement = true;
0B5C  3001     MOVLW 0x1
0B5D  0140     MOVLB 0x0
0B5E  00A0     MOVWF __pcstackBANK0
0B5F  0820     MOVF __pcstackBANK0, W
0B60  0141     MOVLB 0x1
0B61  00BB     MOVWF 0xBB
109:           }
0B62  0008     RETURN
110:           
111:           void check_thresholds_exceeded(void)
112:           {
113:               if(power.batt_threshold.enabled) //  Only set Thresholds when in threshold mode
114:               {
115:                   /* Threshold operation */
116:                   if(power.meas.batt.voltage < power.batt_threshold.thresholdLevelLow){
117:                       power.batt_threshold.underThreshold = true;
118:                   }else if(power.meas.batt.voltage > power.batt_threshold.thresholdLevelHigh){
119:                       power.batt_threshold.overThreshold = true;
120:                   }
121:               }
122:           
123:               if(power.light_threshold.enabled) //  Only set Thresholds when in threshold mode
124:               {
125:                   // Check sensor interrupt register for exceeded thresholds
126:                   if(power.meas.light.data.lux < power.light_threshold.thresholdLevelLow){
127:                       power.light_threshold.underThreshold = true;
128:                   }else if(power.meas.light.data.lux > power.light_threshold.thresholdLevelHigh){
129:                       power.light_threshold.overThreshold = true;
130:                   }
131:               }
132:           }
133:           
134:           void Measure()
135:           {
136:               // Measure battery voltage
137:           //    power.meas.batt.voltage = battery_measure();
138:               
139:               // Get data from light sensor
140:               LED0_SetHigh(); // Led on
0F85  0140     MOVLB 0x0
0F86  179A     BSF LATC, 0x7
141:           //    veml7700_getALS(&power.meas.light.data, &veml7700_config);
142:               __delay_ms(20);
0F87  30D0     MOVLW 0xD0
0F88  0140     MOVLB 0x0
0F89  00CB     MOVWF 0x4B
0F8A  30C9     MOVLW 0xC9
0F8B  0B89     DECFSZ WREG, F
0F8C  2F8B     GOTO 0x78B
0F8D  0BCB     DECFSZ 0x4B, F
0F8E  2F8B     GOTO 0x78B
0F8F  3200     BRA 0xF90
143:               LED0_SetLow();  // Led off
0F90  0140     MOVLB 0x0
0F91  139A     BCF LATC, 0x7
144:               
145:               // Check if any thresholds are exceeded - notify loop
146:           //    check_thresholds_exceeded();
147:               
148:           //    if(power.meas.light.data.lux > 65535){    //  Limit of the 2 byte format
149:           //        power.meas.light.data.lux = 65535;
150:           //    }
151:               
152:               uint16_t datalux = (uint16_t)(round(power.meas.light.data.lux));  //  Do not multiply lux value by 600
0F92  3005     MOVLW 0x5
0F93  3EB3     ADDLW 0xB3
0F94  0086     MOVWF FSR1
0F95  0187     CLRF FSR1H
0F96  3F40     MOVIW [0]FSR1
0F97  00C5     MOVWF x
0F98  3F41     MOVIW [1]FSR1
0F99  00C6     MOVWF 0x46
0F9A  3F42     MOVIW [2]FSR1
0F9B  00C7     MOVWF 0x47
0F9C  318E     MOVLP 0xE
0F9D  2605     CALL 0x605
0F9E  318F     MOVLP 0xF
0F9F  0140     MOVLB 0x0
0FA0  0845     MOVF x, W
0FA1  00D0     MOVWF 0x50
0FA2  0846     MOVF 0x46, W
0FA3  00D1     MOVWF 0x51
0FA4  0847     MOVF 0x47, W
0FA5  00D2     MOVWF 0x52
0FA6  0850     MOVF 0x50, W
0FA7  00A0     MOVWF __pcstackBANK0
0FA8  0851     MOVF 0x51, W
0FA9  00A1     MOVWF length
0FAA  0852     MOVF 0x52, W
0FAB  00A2     MOVWF data
0FAC  3187     MOVLP 0x7
0FAD  2722     CALL 0x722
0FAE  318F     MOVLP 0xF
0FAF  0140     MOVLB 0x0
0FB0  0821     MOVF length, W
0FB1  00CD     MOVWF 0x4D
0FB2  0820     MOVF __pcstackBANK0, W
0FB3  00CC     MOVWF datalux
153:               
154:               // prepare data for I2C transmission: multiply by 600
155:               uint16_t databatvoltage = (uint16_t)(round(power.meas.batt.voltage * 10000)); //  multiply by 10000 as in iWAST configurator
0FB4  0141     MOVLB 0x1
0FB5  0833     MOVF power, W
0FB6  0140     MOVLB 0x0
0FB7  00AB     MOVWF f2
0FB8  0141     MOVLB 0x1
0FB9  0834     MOVF 0xB4, W
0FBA  0140     MOVLB 0x0
0FBB  00AC     MOVWF f2
0FBC  0141     MOVLB 0x1
0FBD  0835     MOVF 0xB5, W
0FBE  0140     MOVLB 0x0
0FBF  00AD     MOVWF exp1
0FC0  3040     MOVLW 0x40
0FC1  00A8     MOVWF f1
0FC2  301C     MOVLW 0x1C
0FC3  00A9     MOVWF lval
0FC4  3046     MOVLW 0x46
0FC5  00AA     MOVWF 0x2A
0FC6  3185     MOVLP 0x5
0FC7  2511     CALL 0x511
0FC8  318F     MOVLP 0xF
0FC9  0140     MOVLB 0x0
0FCA  0828     MOVF f1, W
0FCB  00C5     MOVWF x
0FCC  0829     MOVF lval, W
0FCD  00C6     MOVWF 0x46
0FCE  082A     MOVF 0x2A, W
0FCF  00C7     MOVWF 0x47
0FD0  318E     MOVLP 0xE
0FD1  2605     CALL 0x605
0FD2  318F     MOVLP 0xF
0FD3  0140     MOVLB 0x0
0FD4  0845     MOVF x, W
0FD5  00D0     MOVWF 0x50
0FD6  0846     MOVF 0x46, W
0FD7  00D1     MOVWF 0x51
0FD8  0847     MOVF 0x47, W
0FD9  00D2     MOVWF 0x52
0FDA  0850     MOVF 0x50, W
0FDB  00A0     MOVWF __pcstackBANK0
0FDC  0851     MOVF 0x51, W
0FDD  00A1     MOVWF length
0FDE  0852     MOVF 0x52, W
0FDF  00A2     MOVWF data
0FE0  3187     MOVLP 0x7
0FE1  2722     CALL 0x722
0FE2  318F     MOVLP 0xF
0FE3  0140     MOVLB 0x0
0FE4  0821     MOVF length, W
0FE5  00CF     MOVWF 0x4F
0FE6  0820     MOVF __pcstackBANK0, W
0FE7  00CE     MOVWF databatvoltage
156:               
157:               measurementData[0] = (uint8_t)(databatvoltage>>8);
0FE8  084F     MOVF 0x4F, W
0FE9  00CB     MOVWF 0x4B
0FEA  084B     MOVF 0x4B, W
0FEB  0141     MOVLB 0x1
0FEC  00A5     MOVWF measurementData
158:               measurementData[1] = (uint8_t)(databatvoltage);
0FED  0140     MOVLB 0x0
0FEE  084E     MOVF databatvoltage, W
0FEF  00CB     MOVWF 0x4B
0FF0  084B     MOVF 0x4B, W
0FF1  0141     MOVLB 0x1
0FF2  00A6     MOVWF 0xA6
159:           
160:               measurementData[2] = (uint8_t)(datalux>>8);
0FF3  0140     MOVLB 0x0
0FF4  084D     MOVF 0x4D, W
0FF5  00CB     MOVWF 0x4B
0FF6  084B     MOVF 0x4B, W
0FF7  0141     MOVLB 0x1
0FF8  00A7     MOVWF 0xA7
161:               measurementData[3] = (uint8_t)(datalux);
0FF9  0140     MOVLB 0x0
0FFA  084C     MOVF datalux, W
0FFB  00CB     MOVWF 0x4B
0FFC  084B     MOVF 0x4B, W
0FFD  0141     MOVLB 0x1
0FFE  00A8     MOVWF 0xA8
162:           }
0FFF  0008     RETURN
163:           
164:           
165:           void Power_Loop(){
166:           
167:               if(!power.ctrl.measurementRunning)
0E9C  0141     MOVLB 0x1
0E9D  083C     MOVF 0xBC, W
0E9E  1D03     BTFSS STATUS, 0x2
0E9F  2EA1     GOTO 0x6A1
0EA0  2EA2     GOTO 0x6A2
0EA1  2F0F     GOTO 0x70F
168:               {
169:                   if(power.ctrl.startMeasurement)            //  Polled measurement
0EA2  083B     MOVF 0xBB, W
0EA3  1903     BTFSC STATUS, 0x2
0EA4  2EA6     GOTO 0x6A6
0EA5  2EA7     GOTO 0x6A7
0EA6  2ED5     GOTO 0x6D5
170:                   {
171:                       power.ctrl.startMeasurement = false;
0EA7  01BB     CLRF 0xBB
172:                       
173:                       NOP();
0EA8  0000     NOP
174:                       NOP();
0EA9  0000     NOP
175:                       
176:                       if(WDTCON0bits.SEN == 1)
0EAA  0150     MOVLB 0x10
0EAB  1C0C     BTFSS WDTCON0, 0x0
0EAC  2EAE     GOTO 0x6AE
0EAD  2EAF     GOTO 0x6AF
0EAE  2EC2     GOTO 0x6C2
177:                       {
178:                           WDTCON0bits.SEN = 0;    //  Disable WDT
0EAF  100C     BCF WDTCON0, 0x0
179:                           
180:                           power.ctrl.measurementRunning = true;
0EB0  3001     MOVLW 0x1
0EB1  0140     MOVLB 0x0
0EB2  00D3     MOVWF 0x53
0EB3  0853     MOVF 0x53, W
0EB4  0141     MOVLB 0x1
0EB5  00BC     MOVWF 0xBC
181:                           Measure();              //  Measure
0EB6  318F     MOVLP 0xF
0EB7  2785     CALL 0x785
0EB8  318E     MOVLP 0xE
182:                           power.ctrl.measurementRunning = false;
0EB9  0141     MOVLB 0x1
0EBA  01BC     CLRF 0xBC
183:                           
184:                           generateInt();     //  generate interrupt
0EBB  318B     MOVLP 0xB
0EBC  239D     CALL 0x39D
0EBD  318E     MOVLP 0xE
185:                           CLRWDT();               //  Reset wdt timer
0EBE  0064     CLRWDT
186:                           WDTCON0bits.SEN = 1;    //  enable WDT
0EBF  0150     MOVLB 0x10
0EC0  140C     BSF WDTCON0, 0x0
187:                       }else if(WDTCON0bits.SEN == 0)
0EC1  2F0F     GOTO 0x70F
0EC2  180C     BTFSC WDTCON0, 0x0
0EC3  2EC5     GOTO 0x6C5
0EC4  2EC6     GOTO 0x6C6
0EC5  2F0F     GOTO 0x70F
188:                       {
189:                           power.ctrl.measurementRunning = true;
0EC6  3001     MOVLW 0x1
0EC7  0140     MOVLB 0x0
0EC8  00D3     MOVWF 0x53
0EC9  0853     MOVF 0x53, W
0ECA  0141     MOVLB 0x1
0ECB  00BC     MOVWF 0xBC
190:                           Measure();              //  Measure
0ECC  318F     MOVLP 0xF
0ECD  2785     CALL 0x785
0ECE  318E     MOVLP 0xE
191:                           power.ctrl.measurementRunning = false;
0ECF  0141     MOVLB 0x1
0ED0  01BC     CLRF 0xBC
192:                           
193:                           generateInt();     //  generate interrupt 
0ED1  318B     MOVLP 0xB
0ED2  239D     CALL 0x39D
0ED3  318E     MOVLP 0xE
0ED4  2F0F     GOTO 0x70F
194:                       }
195:                   }else if(STATUSbits.nTO == 0)   //  WDT Timeout
0ED5  0140     MOVLB 0x0
0ED6  1A03     BTFSC STATUS, 0x4
0ED7  2ED9     GOTO 0x6D9
0ED8  2EDA     GOTO 0x6DA
0ED9  2F0B     GOTO 0x70B
196:                   {
197:                       WDTCON0bits.SEN = 0;        //  Disable WDT
0EDA  0150     MOVLB 0x10
0EDB  100C     BCF WDTCON0, 0x0
198:                       
199:                       // Set timeout to 16 sec
200:                       WDTCON0 = 0x1C; // 16 second period
0EDC  301C     MOVLW 0x1C
0EDD  008C     MOVWF WDTCON0
201:                       
202:                       power.ctrl.measurementRunning = true;
0EDE  3001     MOVLW 0x1
0EDF  0140     MOVLB 0x0
0EE0  00D3     MOVWF 0x53
0EE1  0853     MOVF 0x53, W
0EE2  0141     MOVLB 0x1
0EE3  00BC     MOVWF 0xBC
203:                       Measure();              //  Measure
0EE4  318F     MOVLP 0xF
0EE5  2785     CALL 0x785
0EE6  318E     MOVLP 0xE
204:                       power.ctrl.measurementRunning = false;
0EE7  0141     MOVLB 0x1
0EE8  01BC     CLRF 0xBC
205:                       
206:                       // If threshold is exceeded - send interrupt
207:                       if(power.batt_threshold.underThreshold || power.light_threshold.underThreshold 
208:                               || power.batt_threshold.overThreshold || power.light_threshold.overThreshold)
0EE9  0845     MOVF 0xC5, W
0EEA  1D03     BTFSS STATUS, 0x2
0EEB  2EED     GOTO 0x6ED
0EEC  2EEE     GOTO 0x6EE
0EED  2EFD     GOTO 0x6FD
0EEE  084E     MOVF 0xCE, W
0EEF  1D03     BTFSS STATUS, 0x2
0EF0  2EF2     GOTO 0x6F2
0EF1  2EF3     GOTO 0x6F3
0EF2  2EFD     GOTO 0x6FD
0EF3  0844     MOVF 0xC4, W
0EF4  1D03     BTFSS STATUS, 0x2
0EF5  2EF7     GOTO 0x6F7
0EF6  2EF8     GOTO 0x6F8
0EF7  2EFD     GOTO 0x6FD
0EF8  084D     MOVF 0xCD, W
0EF9  1903     BTFSC STATUS, 0x2
0EFA  2EFC     GOTO 0x6FC
0EFB  2EFD     GOTO 0x6FD
0EFC  2F07     GOTO 0x707
209:                       {
210:                           power.batt_threshold.underThreshold = false; //  Reset the states
0EFD  01C5     CLRF 0xC5
211:                           power.light_threshold.underThreshold = false;
0EFE  01CE     CLRF 0xCE
212:                           power.batt_threshold.overThreshold = false;
0EFF  01C4     CLRF 0xC4
213:                           power.light_threshold.overThreshold= false;
0F00  01CD     CLRF 0xCD
214:                           
215:                           generateInt();   
0F01  318B     MOVLP 0xB
0F02  239D     CALL 0x39D
0F03  318E     MOVLP 0xE
216:                           
217:                           // If threshold is exceeded - set watchdog period to 64 sec
218:                           WDTCON0 = 0x20; // 64 second period  
0F04  3020     MOVLW 0x20
0F05  0150     MOVLB 0x10
0F06  008C     MOVWF WDTCON0
219:                       }
220:                       
221:                       CLRWDT();               //  Reset wdt timer
0F07  0064     CLRWDT
222:                       WDTCON0bits.SEN = 1;    //  enable WDT
0F08  0150     MOVLB 0x10
0F09  140C     BSF WDTCON0, 0x0
223:                   }else
0F0A  2F0F     GOTO 0x70F
224:                   {
225:                       Enter_sleep();
0F0B  318B     MOVLP 0xB
0F0C  2355     CALL 0x355
0F0D  318E     MOVLP 0xE
0F0E  2F0F     GOTO 0x70F
226:                   }
227:               }    
228:           }
0F0F  0008     RETURN
229:           
230:           void Power_GetData(uint8_t * data, uint8_t  * length){
231:               *length = 4; // this is fixed (M_NR = 2)
0D11  3004     MOVLW 0x4
0D12  0140     MOVLB 0x0
0D13  00A2     MOVWF data
0D14  0821     MOVF length, W
0D15  0086     MOVWF FSR1
0D16  0187     CLRF FSR1H
0D17  0822     MOVF data, W
0D18  0081     MOVWF INDF1
232:               data[0] = measurementData[0];
0D19  0141     MOVLB 0x1
0D1A  0825     MOVF measurementData, W
0D1B  0140     MOVLB 0x0
0D1C  00A2     MOVWF data
0D1D  0820     MOVF __pcstackBANK0, W
0D1E  0086     MOVWF FSR1
0D1F  3001     MOVLW 0x1
0D20  0087     MOVWF FSR1H
0D21  0822     MOVF data, W
0D22  0081     MOVWF INDF1
233:               data[1] = measurementData[1];
0D23  0141     MOVLB 0x1
0D24  0826     MOVF 0xA6, W
0D25  0140     MOVLB 0x0
0D26  00A2     MOVWF data
0D27  0A20     INCF __pcstackBANK0, W
0D28  0086     MOVWF FSR1
0D29  3001     MOVLW 0x1
0D2A  0087     MOVWF FSR1H
0D2B  0822     MOVF data, W
0D2C  0081     MOVWF INDF1
234:               data[2] = measurementData[2];
0D2D  0141     MOVLB 0x1
0D2E  0827     MOVF 0xA7, W
0D2F  0140     MOVLB 0x0
0D30  00A2     MOVWF data
0D31  0820     MOVF __pcstackBANK0, W
0D32  3E02     ADDLW 0x2
0D33  0086     MOVWF FSR1
0D34  3001     MOVLW 0x1
0D35  0087     MOVWF FSR1H
0D36  0822     MOVF data, W
0D37  0081     MOVWF INDF1
235:               data[3] = measurementData[3];
0D38  0141     MOVLB 0x1
0D39  0828     MOVF 0xA8, W
0D3A  0140     MOVLB 0x0
0D3B  00A2     MOVWF data
0D3C  0820     MOVF __pcstackBANK0, W
0D3D  3E03     ADDLW 0x3
0D3E  0086     MOVWF FSR1
0D3F  3001     MOVLW 0x1
0D40  0087     MOVWF FSR1H
0D41  0822     MOVF data, W
0D42  0081     MOVWF INDF1
236:           }
0D43  0008     RETURN
237:           
238:           void Power_SetThreshold(uint8_t metric, uint8_t * thresholdData){
239:               
240:               uint16_t temp;
241:               
242:               if(metric == METRIC_BATT)     //  Batt Thresholds
0324  0140     MOVLB 0x0
0325  083C     MOVF metric, W
0326  1D03     BTFSS STATUS, 0x2
0327  2B29     GOTO 0x329
0328  2B2A     GOTO 0x32A
0329  2BAC     GOTO 0x3AC
243:               {
244:                   power.batt_threshold.enabled = thresholdData[0];
032A  083D     MOVF thresholdData, W
032B  0086     MOVWF FSR1
032C  3001     MOVLW 0x1
032D  0087     MOVWF FSR1H
032E  0801     MOVF INDF1, W
032F  00BE     MOVWF 0x3E
0330  083E     MOVF 0x3E, W
0331  0141     MOVLB 0x1
0332  00BD     MOVWF 0xBD
245:                   temp = (uint16_t)((thresholdData[1]<<8) | thresholdData[2]);
0333  0140     MOVLB 0x0
0334  083D     MOVF thresholdData, W
0335  3E02     ADDLW 0x2
0336  0086     MOVWF FSR1
0337  3001     MOVLW 0x1
0338  0087     MOVWF FSR1H
0339  0801     MOVF INDF1, W
033A  00BE     MOVWF 0x3E
033B  01BF     CLRF f2
033C  0A3D     INCF thresholdData, W
033D  0086     MOVWF FSR1
033E  3001     MOVLW 0x1
033F  0087     MOVWF FSR1H
0340  0801     MOVF INDF1, W
0341  00C0     MOVWF 0x40
0342  01C1     CLRF 0x41
0343  0840     MOVF 0x40, W
0344  00C1     MOVWF 0x41
0345  01C0     CLRF 0x40
0346  083E     MOVF 0x3E, W
0347  0440     IORWF 0x40, W
0348  00C3     MOVWF temp
0349  083F     MOVF f2, W
034A  0441     IORWF 0x41, W
034B  00C4     MOVWF 0x44
246:                   power.batt_threshold.thresholdLevelLow = (float) temp / 10000;
034C  3040     MOVLW 0x40
034D  00AC     MOVWF f2
034E  301C     MOVLW 0x1C
034F  00AD     MOVWF exp1
0350  3046     MOVLW 0x46
0351  00AE     MOVWF c
0352  0844     MOVF 0x44, W
0353  00A9     MOVWF lval
0354  0843     MOVF temp, W
0355  00A8     MOVWF f1
0356  318B     MOVLP 0xB
0357  23EF     CALL 0x3EF
0358  3183     MOVLP 0x3
0359  0140     MOVLB 0x0
035A  0828     MOVF f1, W
035B  00AF     MOVWF f1
035C  0829     MOVF lval, W
035D  00B0     MOVWF 0x30
035E  082A     MOVF 0x2A, W
035F  00B1     MOVWF 0x31
0360  3185     MOVLP 0x5
0361  25D2     CALL 0x5D2
0362  3183     MOVLP 0x3
0363  0140     MOVLB 0x0
0364  082C     MOVF f2, W
0365  0141     MOVLB 0x1
0366  00C1     MOVWF 0xC1
0367  0140     MOVLB 0x0
0368  082D     MOVF exp1, W
0369  0141     MOVLB 0x1
036A  00C2     MOVWF 0xC2
036B  0140     MOVLB 0x0
036C  082E     MOVF c, W
036D  0141     MOVLB 0x1
036E  00C3     MOVWF 0xC3
247:                   temp = (uint16_t)((thresholdData[3]<<8) | thresholdData[4]);
036F  0140     MOVLB 0x0
0370  083D     MOVF thresholdData, W
0371  3E04     ADDLW 0x4
0372  0086     MOVWF FSR1
0373  3001     MOVLW 0x1
0374  0087     MOVWF FSR1H
0375  0801     MOVF INDF1, W
0376  00BE     MOVWF 0x3E
0377  01BF     CLRF f2
0378  083D     MOVF thresholdData, W
0379  3E03     ADDLW 0x3
037A  0086     MOVWF FSR1
037B  3001     MOVLW 0x1
037C  0087     MOVWF FSR1H
037D  0801     MOVF INDF1, W
037E  00C0     MOVWF 0x40
037F  01C1     CLRF 0x41
0380  0840     MOVF 0x40, W
0381  00C1     MOVWF 0x41
0382  01C0     CLRF 0x40
0383  083E     MOVF 0x3E, W
0384  0440     IORWF 0x40, W
0385  00C3     MOVWF temp
0386  083F     MOVF f2, W
0387  0441     IORWF 0x41, W
0388  00C4     MOVWF 0x44
248:                   power.batt_threshold.thresholdLevelHigh = (float) temp / 10000;   //  Divide thresholds by 100 as in iWAST configurator
0389  3040     MOVLW 0x40
038A  00AC     MOVWF f2
038B  301C     MOVLW 0x1C
038C  00AD     MOVWF exp1
038D  3046     MOVLW 0x46
038E  00AE     MOVWF c
038F  0844     MOVF 0x44, W
0390  00A9     MOVWF lval
0391  0843     MOVF temp, W
0392  00A8     MOVWF f1
0393  318B     MOVLP 0xB
0394  23EF     CALL 0x3EF
0395  3183     MOVLP 0x3
0396  0140     MOVLB 0x0
0397  0828     MOVF f1, W
0398  00AF     MOVWF f1
0399  0829     MOVF lval, W
039A  00B0     MOVWF 0x30
039B  082A     MOVF 0x2A, W
039C  00B1     MOVWF 0x31
039D  3185     MOVLP 0x5
039E  25D2     CALL 0x5D2
039F  3183     MOVLP 0x3
03A0  0140     MOVLB 0x0
03A1  082C     MOVF f2, W
03A2  0141     MOVLB 0x1
03A3  00BE     MOVWF 0xBE
03A4  0140     MOVLB 0x0
03A5  082D     MOVF exp1, W
03A6  0141     MOVLB 0x1
03A7  00BF     MOVWF 0xBF
03A8  0140     MOVLB 0x0
03A9  082E     MOVF c, W
03AA  0141     MOVLB 0x1
03AB  00C0     MOVWF 0xC0
249:               }
250:               if(metric == METRIC_LIGHT)     //  LDR Thresholds
03AC  0140     MOVLB 0x0
03AD  033C     DECF metric, W
03AE  1D03     BTFSS STATUS, 0x2
03AF  2BB1     GOTO 0x3B1
03B0  2BB2     GOTO 0x3B2
03B1  2C14     GOTO 0x414
251:               {
252:                   power.light_threshold.enabled = thresholdData[0];
03B2  083D     MOVF thresholdData, W
03B3  0086     MOVWF FSR1
03B4  3001     MOVLW 0x1
03B5  0087     MOVWF FSR1H
03B6  0801     MOVF INDF1, W
03B7  00BE     MOVWF 0x3E
03B8  083E     MOVF 0x3E, W
03B9  0141     MOVLB 0x1
03BA  00C6     MOVWF 0xC6
253:                   temp = (uint16_t)((thresholdData[1]<<8 | thresholdData[2]));
03BB  0140     MOVLB 0x0
03BC  083D     MOVF thresholdData, W
03BD  3E02     ADDLW 0x2
03BE  0086     MOVWF FSR1
03BF  3001     MOVLW 0x1
03C0  0087     MOVWF FSR1H
03C1  0801     MOVF INDF1, W
03C2  00BE     MOVWF 0x3E
03C3  01BF     CLRF f2
03C4  0A3D     INCF thresholdData, W
03C5  0086     MOVWF FSR1
03C6  3001     MOVLW 0x1
03C7  0087     MOVWF FSR1H
03C8  0801     MOVF INDF1, W
03C9  00C0     MOVWF 0x40
03CA  01C1     CLRF 0x41
03CB  0840     MOVF 0x40, W
03CC  00C1     MOVWF 0x41
03CD  01C0     CLRF 0x40
03CE  083E     MOVF 0x3E, W
03CF  0440     IORWF 0x40, W
03D0  00C3     MOVWF temp
03D1  083F     MOVF f2, W
03D2  0441     IORWF 0x41, W
03D3  00C4     MOVWF 0x44
254:                   power.light_threshold.thresholdLevelLow = (float) temp;
03D4  0844     MOVF 0x44, W
03D5  00A9     MOVWF lval
03D6  0843     MOVF temp, W
03D7  00A8     MOVWF f1
03D8  318B     MOVLP 0xB
03D9  23EF     CALL 0x3EF
03DA  3183     MOVLP 0x3
03DB  0140     MOVLB 0x0
03DC  0828     MOVF f1, W
03DD  0141     MOVLB 0x1
03DE  00CA     MOVWF 0xCA
03DF  0140     MOVLB 0x0
03E0  0829     MOVF lval, W
03E1  0141     MOVLB 0x1
03E2  00CB     MOVWF 0xCB
03E3  0140     MOVLB 0x0
03E4  082A     MOVF 0x2A, W
03E5  0141     MOVLB 0x1
03E6  00CC     MOVWF 0xCC
255:                   temp = (uint16_t)((thresholdData[3]<<8 | thresholdData[4]));
03E7  0140     MOVLB 0x0
03E8  083D     MOVF thresholdData, W
03E9  3E04     ADDLW 0x4
03EA  0086     MOVWF FSR1
03EB  3001     MOVLW 0x1
03EC  0087     MOVWF FSR1H
03ED  0801     MOVF INDF1, W
03EE  00BE     MOVWF 0x3E
03EF  01BF     CLRF f2
03F0  083D     MOVF thresholdData, W
03F1  3E03     ADDLW 0x3
03F2  0086     MOVWF FSR1
03F3  3001     MOVLW 0x1
03F4  0087     MOVWF FSR1H
03F5  0801     MOVF INDF1, W
03F6  00C0     MOVWF 0x40
03F7  01C1     CLRF 0x41
03F8  0840     MOVF 0x40, W
03F9  00C1     MOVWF 0x41
03FA  01C0     CLRF 0x40
03FB  083E     MOVF 0x3E, W
03FC  0440     IORWF 0x40, W
03FD  00C3     MOVWF temp
03FE  083F     MOVF f2, W
03FF  0441     IORWF 0x41, W
0400  00C4     MOVWF 0x44
256:                   power.light_threshold.thresholdLevelHigh = (float) temp;
0401  0844     MOVF 0x44, W
0402  00A9     MOVWF lval
0403  0843     MOVF temp, W
0404  00A8     MOVWF f1
0405  318B     MOVLP 0xB
0406  23EF     CALL 0x3EF
0407  3183     MOVLP 0x3
0408  0140     MOVLB 0x0
0409  0828     MOVF f1, W
040A  0141     MOVLB 0x1
040B  00C7     MOVWF 0xC7
040C  0140     MOVLB 0x0
040D  0829     MOVF lval, W
040E  0141     MOVLB 0x1
040F  00C8     MOVWF 0xC8
0410  0140     MOVLB 0x0
0411  082A     MOVF 0x2A, W
0412  0141     MOVLB 0x1
0413  00C9     MOVWF 0xC9
257:               }
258:               
259:               if(power.batt_threshold.enabled || power.light_threshold.enabled)         //  Threshold -> enable WDT   
0414  0141     MOVLB 0x1
0415  083D     MOVF 0xBD, W
0416  1D03     BTFSS STATUS, 0x2
0417  2C19     GOTO 0x419
0418  2C1A     GOTO 0x41A
0419  2C1F     GOTO 0x41F
041A  0846     MOVF 0xC6, W
041B  1903     BTFSC STATUS, 0x2
041C  2C1E     GOTO 0x41E
041D  2C1F     GOTO 0x41F
041E  2C25     GOTO 0x425
260:               {
261:                   WDTCON0bits.SEN = 0;
041F  0150     MOVLB 0x10
0420  100C     BCF WDTCON0, 0x0
262:                   CLRWDT();
0421  0064     CLRWDT
263:                   WDTCON0bits.SEN = 1;
0422  0150     MOVLB 0x10
0423  140C     BSF WDTCON0, 0x0
264:               }else{                          //  No thresholds -> WDT off 
0424  2C27     GOTO 0x427
265:                   WDTCON0bits.SEN = 0;
0425  0150     MOVLB 0x10
0426  100C     BCF WDTCON0, 0x0
266:               }
267:               
268:               // If enabled - set thresholds to veml7700 registers
269:               if(power.light_threshold.enabled)
0427  0141     MOVLB 0x1
0428  0846     MOVF 0xC6, W
270:               {
271:                   // Set thresholds
272:           //        veml7700_setALS_WH((uint16_t) power.light_threshold.thresholdLevelHigh);
273:           //        veml7700_setALS_WL((uint16_t) power.light_threshold.thresholdLevelLow);
274:               }
275:           }
0429  0008     RETURN
276:           
277:           #endif
278:           #endif
---  C:/Users/JonaCappelle/Documents/Github/sensors/firmware/Power_Module/main.c  -----------------------
1:             /*  ____  ____      _    __  __  ____ ___
2:              * |  _ \|  _ \    / \  |  \/  |/ ___/ _ \
3:              * | | | | |_) |  / _ \ | |\/| | |  | | | |
4:              * | |_| |  _ <  / ___ \| |  | | |__| |_| |
5:              * |____/|_| \_\/_/   \_\_|  |_|\____\___/
6:              *                           research group
7:              *                             dramco.be/
8:              *
9:              *  KU Leuven - Technology Campus Gent,
10:             *  Gebroeders De Smetstraat 1,
11:             *  B-9000 Gent, Belgium
12:             *
13:             *         File: main.c
14:             *      Created: 2019-09-11
15:             *       Author: Geoffrey Ottoy
16:             *      Version: 0.2
17:             *
18:             *  Description: Generic I2C sensor interface for 
19:             *                  "IoT with a SOFT touch"
20:             *               (DRAMCO / KU Leuven TCG project)
21:             *               ------------------------
22:             * 
23:             * -------------------------------------------
24:             * | Current measurements:                    |
25:             * -------------------------------------------
26:             * |     POWER MODULE ONLY - no solar panel:  |
27:             * |             Sleep: +- 2.35 uA            |
28:             * |             Polled: +- 2.35 uA           |
29:             * |             Thresholds based: +- 17.2 uA |
30:             * -------------------------------------------
31:             */
32:            
33:            #include <xc.h>
34:            #include <stdio.h>
35:            #include <stdint.h>
36:            #include <string.h>
37:            #include <stdbool.h>
38:            
39:            #include "global.h"
40:            #include "system/system.h"
41:            #include "system/i2c1.h"
42:            
43:            // include sensor
44:            #include "sensor/power.h"
45:            
46:            
47:            Sensor_API_t sensorAPI = POWER_API;
48:            
49:            uint8_t mData[2 * M_NR];
50:            uint8_t mDataLength;
51:            
52:            void toggleInt(void);
53:            
54:            /* Main application
55:             */
56:            void main(void)
57:            {
58:                // initialize the device
59:                SYSTEM_Initialize(SLAVE_ADDRESS);
042A  3070     MOVLW 0x70
042B  318C     MOVLP 0xC
042C  245B     CALL 0x45B
042D  3184     MOVLP 0x4
60:                
61:                sensorAPI.Init();
042E  0142     MOVLB 0x2
042F  084F     MOVF 0x14F, W
0430  008A     MOVWF PCLATH
0431  084E     MOVF sensorAPI, W
0432  000A     CALLW
0433  3184     MOVLP 0x4
62:                
63:                while(1){
64:                    sensorAPI.Loop();
0434  3004     MOVLW 0x4
0435  3E4E     ADDLW 0x4E
0436  0086     MOVWF FSR1L
0437  3001     MOVLW 0x1
0438  0087     MOVWF FSR1H
0439  3F41     MOVIW [1]FSR1
043A  008A     MOVWF PCLATH
043B  3F40     MOVIW [0]FSR1
043C  000A     CALLW
043D  3184     MOVLP 0x4
65:                    sensorAPI.GetData(mData, &mDataLength);
043E  3042     MOVLW 0x42
043F  0141     MOVLB 0x1
0440  00D6     MOVWF __pcstackBANK1
0441  0856     MOVF __pcstackBANK1, W
0442  0140     MOVLB 0x0
0443  00A0     MOVWF __pcstackBANK0
0444  30D3     MOVLW 0xD3
0445  0141     MOVLB 0x1
0446  00D7     MOVWF 0xD7
0447  0857     MOVF 0xD7, W
0448  0140     MOVLB 0x0
0449  00A1     MOVWF length
044A  3006     MOVLW 0x6
044B  3E4E     ADDLW 0x4E
044C  0086     MOVWF FSR1
044D  3001     MOVLW 0x1
044E  0087     MOVWF FSR1H
044F  3F41     MOVIW [1]FSR1
0450  008A     MOVWF PCLATH
0451  3F40     MOVIW [0]FSR1
0452  000A     CALLW
0453  3184     MOVLP 0x4
66:                    I2C1_SetTransmitData(mData, mDataLength);
0454  0141     MOVLB 0x1
0455  0853     MOVF mDataLength, W
0456  00D6     MOVWF __pcstackBANK1
0457  0856     MOVF __pcstackBANK1, W
0458  0140     MOVLB 0x0
0459  00A0     MOVWF __pcstackBANK0
045A  3042     MOVLW 0x42
045B  318C     MOVLP 0xC
045C  24BC     CALL 0x4BC
045D  3184     MOVLP 0x4
67:                    
68:                    // I2C Slave operation (respond to commands)
69:                    if(I2C1_CommandReceived()){
045E  318B     MOVLP 0xB
045F  233A     CALL 0x33A
0460  3184     MOVLP 0x4
0461  3A00     XORLW 0x0
0462  1903     BTFSC STATUS, 0x2
0463  2C65     GOTO 0x465
0464  2C66     GOTO 0x466
0465  2C34     GOTO 0x434
70:                        uint8_t cmd;
71:                        I2C1_GetCommand(&cmd);
0466  30D8     MOVLW 0xD8
0467  318B     MOVLP 0xB
0468  23BA     CALL 0x3BA
0469  3184     MOVLP 0x4
72:                        
73:                        switch(cmd){
046A  2CF6     GOTO 0x4F6
04F6  0143     MOVLB 0x3
04F7  0858     MOVF cmd, W
04F8  3A10     XORLW 0x10
04F9  1903     BTFSC STATUS, 0x2
04FA  2C6B     GOTO 0x46B
04FB  3A01     XORLW 0x1
04FC  1903     BTFSC STATUS, 0x2
04FD  2C79     GOTO 0x479
04FE  3A02     XORLW 0x2
04FF  1903     BTFSC STATUS, 0x2
0500  2C95     GOTO 0x495
0501  3A07     XORLW 0x7
0502  1903     BTFSC STATUS, 0x2
0503  2CA0     GOTO 0x4A0
0504  3A01     XORLW 0x1
0505  1903     BTFSC STATUS, 0x2
0506  2CC1     GOTO 0x4C1
0507  3A36     XORLW 0x36
0508  1903     BTFSC STATUS, 0x2
0509  2C87     GOTO 0x487
050A  3A07     XORLW 0x7
050B  1903     BTFSC STATUS, 0x2
050C  2CC5     GOTO 0x4C5
050D  2D0E     GOTO 0x50E
74:                            // POLL
75:                            case CMD_POLL:{
76:                                // master polls address -> respond with ack
77:                                uint8_t ack = DEFAULT_ACK;
046B  30AA     MOVLW 0xAA
046C  0141     MOVLB 0x1
046D  00D6     MOVWF __pcstackBANK1
046E  0856     MOVF __pcstackBANK1, W
046F  0143     MOVLB 0x3
0470  00D5     MOVWF ack
78:                                I2C1_SetTransmitData(&ack, 1);
0471  0140     MOVLB 0x0
0472  01A0     CLRF __pcstackBANK0
0473  0AA0     INCF __pcstackBANK0, F
0474  30D5     MOVLW 0xD5
0475  318C     MOVLP 0xC
0476  24BC     CALL 0x4BC
0477  3184     MOVLP 0x4
79:                            } break;
0478  2C34     GOTO 0x434
80:                            
81:                            // TYPE
82:                            case CMD_DEVICE_TYPE:{
83:                                // master requests sensor type -> respond with type
84:                                uint8_t type = TYPE_BYTE;
0479  3004     MOVLW 0x4
047A  0141     MOVLB 0x1
047B  00D6     MOVWF __pcstackBANK1
047C  0856     MOVF __pcstackBANK1, W
047D  0143     MOVLB 0x3
047E  00D6     MOVWF type
85:                                I2C1_SetTransmitData(&type, 1);
047F  0140     MOVLB 0x0
0480  01A0     CLRF __pcstackBANK0
0481  0AA0     INCF __pcstackBANK0, F
0482  30D6     MOVLW 0xD6
0483  318C     MOVLP 0xC
0484  24BC     CALL 0x4BC
0485  3184     MOVLP 0x4
86:                            } break;
0486  2C34     GOTO 0x434
87:            
88:                            // NR OF METRICS
89:                            case CMD_GET_M_NR:{
90:                                // master requests measurement data length -> respond with length
91:                                uint8_t mnr = M_NR;
0487  3002     MOVLW 0x2
0488  0141     MOVLB 0x1
0489  00D6     MOVWF __pcstackBANK1
048A  0856     MOVF __pcstackBANK1, W
048B  0143     MOVLB 0x3
048C  00D7     MOVWF mnr
92:                                I2C1_SetTransmitData(&mnr, 1);
048D  0140     MOVLB 0x0
048E  01A0     CLRF __pcstackBANK0
048F  0AA0     INCF __pcstackBANK0, F
0490  30D7     MOVLW 0xD7
0491  318C     MOVLP 0xC
0492  24BC     CALL 0x4BC
0493  3184     MOVLP 0x4
93:                            } break;
0494  2C34     GOTO 0x434
94:            
95:                            // MEASURE
96:                            case CMD_START_MEASUREMENT:{
97:                                // master forces measurement -> respond with ack
98:                                sensorAPI.Measure();
0495  3002     MOVLW 0x2
0496  3E4E     ADDLW 0x4E
0497  0086     MOVWF FSR1
0498  3001     MOVLW 0x1
0499  0087     MOVWF FSR1H
049A  3F41     MOVIW [1]FSR1
049B  008A     MOVWF PCLATH
049C  3F40     MOVIW [0]FSR1
049D  000A     CALLW
049E  3184     MOVLP 0x4
99:                            } break;
049F  2C34     GOTO 0x434
100:                           
101:                           // GET DATA
102:                           case CMD_GET_M_DATA:{ // master requests measurement data -> send data
103:                               // wait until data are sent
104:                               uint8_t retries = 20;
04A0  3014     MOVLW 0x14
04A1  0141     MOVLB 0x1
04A2  00D6     MOVWF __pcstackBANK1
04A3  0856     MOVF __pcstackBANK1, W
04A4  0143     MOVLB 0x3
04A5  00D4     MOVWF retries
105:                               while(!I2C1_TxBufferEmpty() && retries--){
04A6  2CB0     GOTO 0x4B0
04B0  318B     MOVLP 0xB
04B1  2363     CALL 0x363
04B2  3184     MOVLP 0x4
04B3  3A00     XORLW 0x0
04B4  1D03     BTFSS STATUS, 0x2
04B5  2CB7     GOTO 0x4B7
04B6  2CB8     GOTO 0x4B8
04B7  2D0E     GOTO 0x50E
04B8  3001     MOVLW 0x1
04B9  0143     MOVLB 0x3
04BA  02D4     SUBWF retries, F
04BB  0A54     INCF retries, W
04BC  1D03     BTFSS STATUS, 0x2
04BD  2CBF     GOTO 0x4BF
04BE  2CC0     GOTO 0x4C0
04BF  2CA7     GOTO 0x4A7
04C0  2C34     GOTO 0x434
106:                                   __delay_ms(1);
04A7  300B     MOVLW 0xB
04A8  0141     MOVLB 0x1
04A9  00D6     MOVWF __pcstackBANK1
04AA  3062     MOVLW 0x62
04AB  0B89     DECFSZ WREG, F
04AC  2CAB     GOTO 0x4AB
04AD  0BD6     DECFSZ __pcstackBANK1, F
04AE  2CAB     GOTO 0x4AB
04AF  0000     NOP
107:                               }
108:                           } break;
109:                           
110:                           // INT TOGGLE
111:                           case CMD_INT_TOGGLE:{ //toggle the INT line      
112:                               toggleInt();
04C1  318B     MOVLP 0xB
04C2  2382     CALL 0x382
04C3  3184     MOVLP 0x4
113:                           } break;
04C4  2C34     GOTO 0x434
114:                           
115:                           // INT TOGGLE
116:                           case CMD_SET_THRESHOLDS:{ //read thresholds
117:                               __delay_ms(2);
04C5  3015     MOVLW 0x15
04C6  0141     MOVLB 0x1
04C7  00D6     MOVWF __pcstackBANK1
04C8  30C6     MOVLW 0xC6
04C9  0B89     DECFSZ WREG, F
04CA  2CC9     GOTO 0x4C9
04CB  0BD6     DECFSZ __pcstackBANK1, F
04CC  2CC9     GOTO 0x4C9
04CD  0000     NOP
118:                               uint8_t len;
119:                               uint8_t data[20];
120:                               I2C1_GetCommandData(data, &len);
04CE  30D9     MOVLW 0xD9
04CF  0141     MOVLB 0x1
04D0  00D6     MOVWF __pcstackBANK1
04D1  0856     MOVF __pcstackBANK1, W
04D2  0140     MOVLB 0x0
04D3  00A0     MOVWF __pcstackBANK0
04D4  30C0     MOVLW 0xC0
04D5  318C     MOVLP 0xC
04D6  247A     CALL 0x47A
04D7  3184     MOVLP 0x4
121:                               if(len == 6){
04D8  3006     MOVLW 0x6
04D9  0143     MOVLB 0x3
04DA  0659     XORWF len, W
04DB  1D03     BTFSS STATUS, 0x2
04DC  2CDE     GOTO 0x4DE
04DD  2CDF     GOTO 0x4DF
04DE  2D0E     GOTO 0x50E
122:                                   sensorAPI.UpdateThreshold(data[0], data+1);
04DF  0840     MOVF __pcstackBANK3, W
04E0  0141     MOVLB 0x1
04E1  00D6     MOVWF __pcstackBANK1
04E2  0856     MOVF __pcstackBANK1, W
04E3  0140     MOVLB 0x0
04E4  00BC     MOVWF metric
04E5  30C1     MOVLW 0xC1
04E6  0141     MOVLB 0x1
04E7  00D7     MOVWF 0xD7
04E8  0857     MOVF 0xD7, W
04E9  0140     MOVLB 0x0
04EA  00BD     MOVWF thresholdData
04EB  3008     MOVLW 0x8
04EC  3E4E     ADDLW 0x4E
04ED  0086     MOVWF FSR1
04EE  3001     MOVLW 0x1
04EF  0087     MOVWF FSR1H
04F0  3F41     MOVIW [1]FSR1
04F1  008A     MOVWF PCLATH
04F2  3F40     MOVIW [0]FSR1
04F3  000A     CALLW
04F4  3184     MOVLP 0x4
04F5  2C34     GOTO 0x434
123:                               }
124:                           } break;
125:                           
126:                           // DO NOTHING
127:                           default:{
128:                           } break;
129:                       }
130:                   }
050E  2C34     GOTO 0x434
050F  3180     MOVLP 0x0
131:               }
132:           }
133:           
134:           void toggleInt(void){
135:               READY_Toggle();
0B82  1003     BCF STATUS, 0x0
0B83  0140     MOVLB 0x0
0B84  1C1A     BTFSS LATC, 0x0
0B85  1403     BSF STATUS, 0x0
0B86  1803     BTFSC STATUS, 0x0
0B87  2B89     GOTO 0x389
0B88  2B8C     GOTO 0x38C
0B89  0140     MOVLB 0x0
0B8A  141A     BSF LATC, 0x0
0B8B  2B8E     GOTO 0x38E
0B8C  0140     MOVLB 0x0
0B8D  101A     BCF LATC, 0x0
136:           }
0B8E  0008     RETURN
137:           
138:           /**
139:            End of File
140:           */
---  C:/Users/JONACA~1/AppData/Local/Temp/skukx.s  ------------------------------------------------------
07FA  00FE     MOVWF 0x7E
07FB  0012     MOVIW FSR0++
07FC  001E     MOVWI FSR1++
07FD  0BFE     DECFSZ 0x7E, F
07FE  2FFB     GOTO 0x7FB
07FF  3400     RETLW 0x0
0045  318B     MOVLP 0xB
0048  00FC     MOVWF I2C1_slaveWriteData
0049  0141     MOVLB 0x1
004A  3180     MOVLP 0x0
004D  00D4     MOVWF SensorInterruptHandler
004E  3180     MOVLP 0x0
0051  00D5     MOVWF 0xD5
0052  306B     MOVLW 0x6B
0053  0084     MOVWF FSR0L
0054  308B     MOVLW 0x8B
0055  0085     MOVWF FSR0H
0056  304E     MOVLW 0x4E
0057  0086     MOVWF FSR1L
0058  3001     MOVLW 0x1
0059  0087     MOVWF FSR1H
005A  300A     MOVLW 0xA
005B  3187     MOVLP 0x7
0B4F  0064     CLRWDT
0B50  0180     CLRF INDF0
0B51  3101     ADDFSR 0, 1
0B52  0B89     DECFSZ WREG, F
0B53  2B50     GOTO 0x350
0B54  3400     RETLW 0x0
005E  01F0     CLRF 0xF0
005F  01F1     CLRF 0xF1
0060  01F2     CLRF 0xF2
0061  01F3     CLRF 0xF3
0062  01F4     CLRF 0xF4
0063  01F5     CLRF 0xF5
0064  0140     MOVLB 0x0
0065  01D4     CLRF __pbssBANK0
0066  01D5     CLRF p_i2c2_current
0067  01D6     CLRF i2c2_trb_count
0068  01D7     CLRF i2c2_state
0069  30A0     MOVLW 0xA0
006A  0084     MOVWF FSR0
006B  3000     MOVLW 0x0
006C  0085     MOVWF FSR0H
006D  3034     MOVLW 0x34
006E  318B     MOVLP 0xB
0071  3020     MOVLW 0x20
0072  0084     MOVWF FSR0
0073  3001     MOVLW 0x1
0074  0085     MOVWF FSR0H
0075  302E     MOVLW 0x2E
0076  318B     MOVLP 0xB
0079  30A0     MOVLW 0xA0
007A  0084     MOVWF FSR0
007B  3001     MOVLW 0x1
007C  0085     MOVWF FSR0H
007D  3020     MOVLW 0x20
007E  318B     MOVLP 0xB
0081  107E     BCF 0x7E, 0x0
0082  0140     MOVLB 0x0
0083  3184     MOVLP 0x4
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/trunc.c  -------------------------------
1:             #include	<math.h>
2:             #include	<limits.h>
3:             #include	<float.h>
4:             
5:             #if	__SIZEOF_DOUBLE__ <= __SIZEOF_LONG__
6:             #define	_frndint(x)	((double)(long)(x))
7:             #else
8:             extern double	_frndint(double);
9:             #endif
10:            
11:            
12:            double
13:            trunc(double x)
14:            {
15:            	double	i;
16:            	int	expon;
17:            
18:            	frexp(x, &expon);
0DBE  0140     MOVLB 0x0
0DBF  0836     MOVF cntr, W
0DC0  00A0     MOVWF __pcstackBANK0
0DC1  0837     MOVF sign, W
0DC2  00A1     MOVWF length
0DC3  0838     MOVF f3, W
0DC4  00A2     MOVWF data
0DC5  303D     MOVLW 0x3D
0DC6  00B9     MOVWF 0x39
0DC7  0839     MOVF 0x39, W
0DC8  00A3     MOVWF data
0DC9  318D     MOVLP 0xD
0DCA  2544     CALL 0x544
0DCB  318D     MOVLP 0xD
19:            	if(expon < 0)
0DCC  0140     MOVLB 0x0
0DCD  1FBE     BTFSS 0x3E, 0x7
0DCE  2DD0     GOTO 0x5D0
0DCF  2DD1     GOTO 0x5D1
0DD0  2DD8     GOTO 0x5D8
20:            		return 0.0;
0DD1  3000     MOVLW 0x0
0DD2  00B6     MOVWF cntr
0DD3  3000     MOVLW 0x0
0DD4  00B7     MOVWF sign
0DD5  3000     MOVLW 0x0
0DD6  00B8     MOVWF f3
0DD7  2E04     GOTO 0x604
21:            	if((unsigned)expon > sizeof(double) * CHAR_BIT - 4)
0DD8  3000     MOVLW 0x0
0DD9  023E     SUBWF 0x3E, W
0DDA  3015     MOVLW 0x15
0DDB  1903     BTFSC STATUS, 0x2
0DDC  023D     SUBWF thresholdData, W
0DDD  1C03     BTFSS STATUS, 0x0
0DDE  2DE0     GOTO 0x5E0
0DDF  2DE1     GOTO 0x5E1
0DE0  2DE2     GOTO 0x5E2
22:            		return x;		/* already an integer */
0DE1  2E04     GOTO 0x604
23:            	i = _frndint(x);
0DE2  0836     MOVF cntr, W
0DE3  00A0     MOVWF __pcstackBANK0
0DE4  0837     MOVF sign, W
0DE5  00A1     MOVWF length
0DE6  0838     MOVF f3, W
0DE7  00A2     MOVWF data
0DE8  3187     MOVLP 0x7
0DE9  2722     CALL 0x722
0DEA  318D     MOVLP 0xD
0DEB  0140     MOVLB 0x0
0DEC  0823     MOVF data, W
0DED  00B1     MOVWF 0x31
0DEE  0822     MOVF data, W
0DEF  00B0     MOVWF 0x30
0DF0  0821     MOVF length, W
0DF1  00AF     MOVWF f1
0DF2  0820     MOVF __pcstackBANK0, W
0DF3  00AE     MOVWF c
0DF4  318D     MOVLP 0xD
0DF5  257C     CALL 0x57C
0DF6  318D     MOVLP 0xD
0DF7  0140     MOVLB 0x0
0DF8  082E     MOVF c, W
0DF9  00BA     MOVWF i
0DFA  082F     MOVF f1, W
0DFB  00BB     MOVWF sign
0DFC  0830     MOVF 0x30, W
0DFD  00BC     MOVWF metric
24:            	return i;
0DFE  083A     MOVF i, W
0DFF  00B6     MOVWF cntr
0E00  083B     MOVF sign, W
0E01  00B7     MOVWF sign
0E02  083C     MOVF metric, W
0E03  00B8     MOVWF f3
25:            }
0E04  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/round.c  -------------------------------
1:             #include	<math.h>
2:             #include	<limits.h>
3:             #include	<float.h>
4:             
5:             double
6:             round(double x)
7:             {
8:             	double	f;
9:             
10:            	f = x-trunc(x);
0E05  0140     MOVLB 0x0
0E06  0845     MOVF x, W
0E07  00B6     MOVWF cntr
0E08  0846     MOVF 0x46, W
0E09  00B7     MOVWF sign
0E0A  0847     MOVF 0x47, W
0E0B  00B8     MOVWF f3
0E0C  318D     MOVLP 0xD
0E0D  25BE     CALL 0x5BE
0E0E  318E     MOVLP 0xE
0E0F  0140     MOVLB 0x0
0E10  0836     MOVF cntr, W
0E11  00BF     MOVWF f2
0E12  0837     MOVF sign, W
0E13  00C0     MOVWF 0x40
0E14  0838     MOVF f3, W
0E15  00C1     MOVWF 0x41
0E16  0845     MOVF x, W
0E17  00C2     MOVWF f1
0E18  0846     MOVF 0x46, W
0E19  00C3     MOVWF temp
0E1A  0847     MOVF 0x47, W
0E1B  00C4     MOVWF 0x44
0E1C  318C     MOVLP 0xC
0E1D  249B     CALL 0x49B
0E1E  318E     MOVLP 0xE
0E1F  0140     MOVLB 0x0
0E20  083F     MOVF f2, W
0E21  00C8     MOVWF f
0E22  0840     MOVF 0x40, W
0E23  00C9     MOVWF 0x49
0E24  0841     MOVF 0x41, W
0E25  00CA     MOVWF 0x4A
11:            	x += f;
0E26  0848     MOVF f, W
0E27  00A8     MOVWF f1
0E28  0849     MOVF 0x49, W
0E29  00A9     MOVWF lval
0E2A  084A     MOVF 0x4A, W
0E2B  00AA     MOVWF 0x2A
0E2C  0845     MOVF x, W
0E2D  00AB     MOVWF f2
0E2E  0846     MOVF 0x46, W
0E2F  00AC     MOVWF f2
0E30  0847     MOVF 0x47, W
0E31  00AD     MOVWF exp1
0E32  3182     MOVLP 0x2
0E33  2204     CALL 0x204
0E34  318E     MOVLP 0xE
0E35  0140     MOVLB 0x0
0E36  0828     MOVF f1, W
0E37  00C5     MOVWF x
0E38  0829     MOVF lval, W
0E39  00C6     MOVWF 0x46
0E3A  082A     MOVF 0x2A, W
0E3B  00C7     MOVWF 0x47
12:            	return trunc(x);
0E3C  0845     MOVF x, W
0E3D  00B6     MOVWF cntr
0E3E  0846     MOVF 0x46, W
0E3F  00B7     MOVWF sign
0E40  0847     MOVF 0x47, W
0E41  00B8     MOVWF f3
0E42  318D     MOVLP 0xD
0E43  25BE     CALL 0x5BE
0E44  318E     MOVLP 0xE
0E45  0140     MOVLB 0x0
0E46  0836     MOVF cntr, W
0E47  00C5     MOVWF x
0E48  0837     MOVF sign, W
0E49  00C6     MOVWF 0x46
0E4A  0838     MOVF f3, W
0E4B  00C7     MOVWF 0x47
13:            }
0E4C  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/memset.c  ------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             __far void *
5:             memset(__far void * p1, int c, register size_t n)
6:             #else /*  _PIC16 */
7:             void *
8:             memset(void * p1, int c, register size_t n)
0C3C  0140     MOVLB 0x0
0C3D  00A5     MOVWF p1
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register __far char *	p;
14:            #else /*  _PIC16 */
15:            	register char *		p;
16:            #endif /* _PIC16 */
17:            
18:            	p = p1;
0C3E  0825     MOVF p1, W
0C3F  00A4     MOVWF sign
0C40  0824     MOVF sign, W
0C41  00A6     MOVWF p
19:            	while(n--)
0C42  2C4E     GOTO 0x44E
0C4E  3001     MOVLW 0x1
0C4F  02A2     SUBWF data, F
0C50  3000     MOVLW 0x0
0C51  3BA3     SUBWFB data, F
0C52  0A22     INCF data, W
0C53  1D03     BTFSS STATUS, 0x2
0C54  2C59     GOTO 0x459
0C55  0A23     INCF data, W
0C56  1D03     BTFSS STATUS, 0x2
0C57  2C59     GOTO 0x459
0C58  2C5A     GOTO 0x45A
0C59  2C43     GOTO 0x443
20:            		*p++ = c;
0C43  0820     MOVF __pcstackBANK0, W
0C44  00A4     MOVWF sign
0C45  0826     MOVF p, W
0C46  0086     MOVWF FSR1
0C47  0187     CLRF FSR1H
0C48  0824     MOVF sign, W
0C49  0081     MOVWF INDF1
0C4A  3001     MOVLW 0x1
0C4B  00A4     MOVWF sign
0C4C  0824     MOVF sign, W
0C4D  07A6     ADDWF p, F
0C4E  3001     MOVLW 0x1
0C4F  02A2     SUBWF data, F
0C50  3000     MOVLW 0x0
0C51  3BA3     SUBWFB data, F
0C52  0A22     INCF data, W
0C53  1D03     BTFSS STATUS, 0x2
0C54  2C59     GOTO 0x459
0C55  0A23     INCF data, W
0C56  1D03     BTFSS STATUS, 0x2
0C57  2C59     GOTO 0x459
0C58  2C5A     GOTO 0x45A
0C59  2C43     GOTO 0x443
21:            	return p1;
22:            }
0C5A  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/lwtoft.c  ------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert unsigned int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(__uint24 *)&f1)
15:            float
16:            __lwtoft(unsigned int c)
17:            {
18:            	float	f1;
19:            	
20:            	if(c == 0)
21:            		return 0.0;
22:            	f1_as_mant1 = c;
23:            	__ftpack(&f1_as_mant1, 127+15);
24:            	return f1;
25:            }
26:            #else
27:            float
28:            __lwtoft(unsigned int c)
29:            {
30:            	return __ftpack(c, 127+15, 0);
0BEF  0140     MOVLB 0x0
0BF0  0828     MOVF f1, W
0BF1  00A0     MOVWF __pcstackBANK0
0BF2  0829     MOVF lval, W
0BF3  00A1     MOVWF length
0BF4  01A2     CLRF data
0BF5  308E     MOVLW 0x8E
0BF6  00AB     MOVWF f2
0BF7  082B     MOVF f2, W
0BF8  00A3     MOVWF data
0BF9  01A4     CLRF sign
0BFA  318F     MOVLP 0xF
0BFB  2710     CALL 0x710
0BFC  318B     MOVLP 0xB
0BFD  0140     MOVLB 0x0
0BFE  0820     MOVF __pcstackBANK0, W
0BFF  00A8     MOVWF f1
0C00  0821     MOVF length, W
0C01  00A9     MOVWF lval
0C02  0822     MOVF data, W
0C03  00AA     MOVWF 0x2A
31:            }
0C04  0008     RETURN
32:            #endif
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/fttol.c  -------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(__uint24 *)&f1)
11:            
12:            // Convert float to long
13:            
14:            #ifdef _OLDLIB
15:            long
16:            __fttol(float f1)
17:            {
18:            	unsigned char	sign1, exp1;
19:            	unsigned long	lval;
20:            
21:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:            	lval = f1_as_mant1;
23:            	exp1 -= 127+15;
24:            	if((signed char)exp1 < 0) {
25:            		if((signed char)exp1 < -15)
26:            			return 0;
27:            		do
28:            			lval >>= 1;
29:            		while(++exp1 != 0);
30:            	} else {
31:            		if(exp1 >= 32)
32:            			return 00;
33:            		while(exp1 != 0) {
34:            			lval <<= 1;
35:            			exp1--;
36:            		}
37:            	}
38:            	if(sign1)
39:            		lval = -lval;
40:            	return lval;
41:            }
42:            #else
43:            long
44:            __fttol(float f1)
45:            {
46:            	unsigned char	sign1, exp1;
47:            	unsigned long	lval;
48:            
49:            	if((exp1 = f1_as_mant1 >> 15) == 0)
0722  0140     MOVLB 0x0
0723  0820     MOVF __pcstackBANK0, W
0724  00A4     MOVWF sign
0725  0821     MOVF length, W
0726  00A5     MOVWF p1
0727  0822     MOVF data, W
0728  00A6     MOVWF p
0729  1003     BCF STATUS, 0x0
072A  0D25     RLF p1, W
072B  0D26     RLF p, W
072C  00A7     MOVWF 0x27
072D  0827     MOVF 0x27, W
072E  00AD     MOVWF exp1
072F  082D     MOVF exp1, W
0730  1D03     BTFSS STATUS, 0x2
0731  2F33     GOTO 0x733
0732  2F34     GOTO 0x734
0733  2F3D     GOTO 0x73D
50:            		return 0;
0734  3000     MOVLW 0x0
0735  00A3     MOVWF data
0736  3000     MOVLW 0x0
0737  00A2     MOVWF data
0738  3000     MOVLW 0x0
0739  00A1     MOVWF length
073A  3000     MOVLW 0x0
073B  00A0     MOVWF __pcstackBANK0
073C  2FA6     GOTO 0x7A6
51:            	sign1 = f1_as_mant1 >> 23;
073D  0820     MOVF __pcstackBANK0, W
073E  00A4     MOVWF sign
073F  0821     MOVF length, W
0740  00A5     MOVWF p1
0741  0822     MOVF data, W
0742  00A6     MOVWF p
0743  3017     MOVLW 0x17
0744  36A6     LSRF p, F
0745  0CA5     RRF p1, F
0746  0CA4     RRF sign, F
0747  0B89     DECFSZ WREG, F
0748  2F44     GOTO 0x744
0749  0824     MOVF sign, W
074A  00A7     MOVWF 0x27
074B  0827     MOVF 0x27, W
074C  00A8     MOVWF f1
52:            	f1_as_mant1 |= 0x8000UL;
074D  17A1     BSF length, 0x7
53:            	f1_as_mant1 &= 0xFFFFUL;
074E  30FF     MOVLW 0xFF
074F  05A0     ANDWF __pcstackBANK0, F
0750  30FF     MOVLW 0xFF
0751  05A1     ANDWF length, F
0752  3000     MOVLW 0x0
0753  05A2     ANDWF data, F
54:            	lval = f1_as_mant1;
0754  0820     MOVF __pcstackBANK0, W
0755  00A9     MOVWF lval
0756  0821     MOVF length, W
0757  00AA     MOVWF 0x2A
0758  0822     MOVF data, W
0759  00AB     MOVWF f2
075A  01AC     CLRF f2
55:            	exp1 -= 127+15;
075B  308E     MOVLW 0x8E
075C  02AD     SUBWF exp1, F
56:            	if((signed char)exp1 < 0) {
075D  1FAD     BTFSS exp1, 0x7
075E  2F60     GOTO 0x760
075F  2F61     GOTO 0x761
0760  2F79     GOTO 0x779
57:            		if((signed char)exp1 < -15)
0761  082D     MOVF exp1, W
0762  3A80     XORLW 0x80
0763  3E8F     ADDLW 0x8F
0764  1803     BTFSC STATUS, 0x0
0765  2F67     GOTO 0x767
0766  2F68     GOTO 0x768
0767  2F69     GOTO 0x769
0768  2F34     GOTO 0x734
58:            			return 0;
59:            		do
60:            			lval >>= 1;
0769  3001     MOVLW 0x1
076A  36AC     LSRF f2, F
076B  0CAB     RRF f2, F
076C  0CAA     RRF 0x2A, F
076D  0CA9     RRF lval, F
076E  0B89     DECFSZ WREG, F
076F  2F6A     GOTO 0x76A
61:            		while(++exp1 != 0);
0770  3001     MOVLW 0x1
0771  00A4     MOVWF sign
0772  0824     MOVF sign, W
0773  07AD     ADDWF exp1, F
0774  1D03     BTFSS STATUS, 0x2
0775  2F77     GOTO 0x777
0776  2F78     GOTO 0x778
0777  2F69     GOTO 0x769
0778  2F8E     GOTO 0x78E
62:            	} else {
63:            		if(exp1 >= 24)
0779  3018     MOVLW 0x18
077A  022D     SUBWF exp1, W
077B  1C03     BTFSS STATUS, 0x0
077C  2F7E     GOTO 0x77E
077D  2F7F     GOTO 0x77F
077E  2F89     GOTO 0x789
077F  2F34     GOTO 0x734
64:            			return 0;
65:            		while(exp1 != 0) {
66:            			lval <<= 1;
0780  3001     MOVLW 0x1
0781  35A9     LSLF lval, F
0782  0DAA     RLF 0x2A, F
0783  0DAB     RLF f2, F
0784  0DAC     RLF f2, F
0785  0B89     DECFSZ WREG, F
0786  2F81     GOTO 0x781
67:            			exp1--;
0787  3001     MOVLW 0x1
0788  02AD     SUBWF exp1, F
68:            		}
0789  082D     MOVF exp1, W
078A  1D03     BTFSS STATUS, 0x2
078B  2F8D     GOTO 0x78D
078C  2F8E     GOTO 0x78E
078D  2F80     GOTO 0x780
69:            	}
70:            	if(sign1)
078E  0828     MOVF f1, W
078F  1903     BTFSC STATUS, 0x2
0790  2F92     GOTO 0x792
0791  2F93     GOTO 0x793
0792  2F9E     GOTO 0x79E
71:            		lval = -lval;
0793  09A9     COMF lval, F
0794  09AA     COMF 0x2A, F
0795  09AB     COMF f2, F
0796  09AC     COMF f2, F
0797  0AA9     INCF lval, F
0798  1903     BTFSC STATUS, 0x2
0799  0AAA     INCF 0x2A, F
079A  1903     BTFSC STATUS, 0x2
079B  0AAB     INCF f2, F
079C  1903     BTFSC STATUS, 0x2
079D  0AAC     INCF f2, F
72:            	return lval;
079E  082C     MOVF f2, W
079F  00A3     MOVWF data
07A0  082B     MOVF f2, W
07A1  00A2     MOVWF data
07A2  082A     MOVF 0x2A, W
07A3  00A1     MOVWF length
07A4  0829     MOVF lval, W
07A5  00A0     MOVWF __pcstackBANK0
73:            }
07A6  0008     RETURN
74:            #endif
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/ftsub.c  -------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(__uint24 *)&f1)
11:            #define	f2_as_mant2	(*(__uint24 *)&f2)
12:            
13:            // floating addition
14:            
15:            float
16:            #ifdef __PICC__
17:            __ftsub(float f2, float f1)
18:            #else
19:            __ftsub(float f1, float f2)
20:            #endif
21:            {
22:            	if (f2 != 0) {
0C9B  0140     MOVLB 0x0
0C9C  0841     MOVF 0x41, W
0C9D  0440     IORWF 0x40, W
0C9E  043F     IORWF f2, W
0C9F  1903     BTFSC STATUS, 0x2
0CA0  2CA2     GOTO 0x4A2
0CA1  2CA3     GOTO 0x4A3
0CA2  2CA5     GOTO 0x4A5
23:            		f2_as_mant2 ^= 0x800000;
0CA3  3080     MOVLW 0x80
0CA4  06C1     XORWF 0x41, F
24:            	}
25:            	return __ftadd(f1, f2);
0CA5  0842     MOVF f1, W
0CA6  00A8     MOVWF f1
0CA7  0843     MOVF temp, W
0CA8  00A9     MOVWF lval
0CA9  0844     MOVF 0x44, W
0CAA  00AA     MOVWF 0x2A
0CAB  083F     MOVF f2, W
0CAC  00AB     MOVWF f2
0CAD  0840     MOVF 0x40, W
0CAE  00AC     MOVWF f2
0CAF  0841     MOVF 0x41, W
0CB0  00AD     MOVWF exp1
0CB1  3182     MOVLP 0x2
0CB2  2204     CALL 0x204
0CB3  318C     MOVLP 0xC
0CB4  0140     MOVLB 0x0
0CB5  0828     MOVF f1, W
0CB6  00BF     MOVWF f2
0CB7  0829     MOVF lval, W
0CB8  00C0     MOVWF 0x40
0CB9  082A     MOVF 0x2A, W
0CBA  00C1     MOVWF 0x41
26:            }
0CBB  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/ftmul.c  -------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #ifdef _PIC18
9:             #define _Has_hardware_multiply 1
10:            #else
11:            #define _Has_hardware_multiply 0
12:            #endif
13:            
14:            #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
15:            #define _Has_large_call_stack 1
16:            #else
17:            #define _Has_large_call_stack 0
18:            #endif
19:            
20:            #include	"ftarith.h"
21:            
22:            #define	f1_as_plier	(*(__uint24 *)&f1)
23:            #define	f2_as_plicand	(*(__uint24 *)&f2)
24:            
25:            // floating addition
26:            #ifdef _OLDLIB
27:            #define	f3_as_product		(*(__uint24 *)&f3)
28:            float
29:            __ftmul(float f1, float f2)
30:            {
31:            	unsigned char	exp1, sign1, cntr;
32:            	float	f3;
33:            	
34:            	f3_as_product = 0;
35:            	sign1 = __ftunpack(&f1_as_plier, &exp1);
36:            	sign1 ^= __ftunpack(&f2_as_plicand, &cntr);
37:            	if(cntr == 0 || exp1 == 0)
38:            		return f3;
39:            	exp1 += cntr-127-6;	// compute new exponent
40:            	cntr = 7;
41:            	do {
42:            		if(f1_as_plier & 1)
43:            			f3_as_product += f2_as_plicand;
44:            		f1_as_plier >>= 1;
45:            		f2_as_plicand <<= 1;
46:            	} while(--cntr != 0);
47:            	cntr = 9;
48:            	do {
49:            		if(f1_as_plier & 1)
50:            			f3_as_product += f2_as_plicand;
51:            		f1_as_plier >>= 1;
52:            		f3_as_product >>= 1;
53:            	} while(--cntr != 0);
54:            	__ftpack(&f3_as_product, exp1);
55:            	if(sign1)
56:            		f3_as_product |= 0x800000;
57:            	return f3;
58:            }
59:            #else
60:            #define	exp2	sign
61:            float
62:            __ftmul(float f1, float f2)
63:            {
64:            	unsigned char	exp, sign, cntr;
65:            	__uint24	f3_as_product;
66:            
67:            	if((exp = f1_as_plier >> 15) == 0)
0511  0140     MOVLB 0x0
0512  0828     MOVF f1, W
0513  00AE     MOVWF c
0514  0829     MOVF lval, W
0515  00AF     MOVWF f1
0516  082A     MOVF 0x2A, W
0517  00B0     MOVWF 0x30
0518  1003     BCF STATUS, 0x0
0519  0D2F     RLF f1, W
051A  0D30     RLF 0x30, W
051B  00B1     MOVWF 0x31
051C  0831     MOVF 0x31, W
051D  00B2     MOVWF sign
051E  0832     MOVF sign, W
051F  1D03     BTFSS STATUS, 0x2
0520  2D22     GOTO 0x522
0521  2D23     GOTO 0x523
0522  2D2A     GOTO 0x52A
68:            		return 0.0;
0523  3000     MOVLW 0x0
0524  00A8     MOVWF f1
0525  3000     MOVLW 0x0
0526  00A9     MOVWF lval
0527  3000     MOVLW 0x0
0528  00AA     MOVWF 0x2A
0529  2DD1     GOTO 0x5D1
69:            	if((exp2 = f2_as_plicand >> 15) == 0)
052A  082B     MOVF f2, W
052B  00AE     MOVWF c
052C  082C     MOVF f2, W
052D  00AF     MOVWF f1
052E  082D     MOVF exp1, W
052F  00B0     MOVWF 0x30
0530  1003     BCF STATUS, 0x0
0531  0D2F     RLF f1, W
0532  0D30     RLF 0x30, W
0533  00B1     MOVWF 0x31
0534  0831     MOVF 0x31, W
0535  00B7     MOVWF sign
0536  0837     MOVF sign, W
0537  1D03     BTFSS STATUS, 0x2
0538  2D3A     GOTO 0x53A
0539  2D3B     GOTO 0x53B
053A  2D42     GOTO 0x542
70:            		return 0.0;
053B  3000     MOVLW 0x0
053C  00A8     MOVWF f1
053D  3000     MOVLW 0x0
053E  00A9     MOVWF lval
053F  3000     MOVLW 0x0
0540  00AA     MOVWF 0x2A
0541  2DD1     GOTO 0x5D1
71:            	exp += exp2-127-6;	// compute new exponent
0542  0837     MOVF sign, W
0543  3E7B     ADDLW 0x7B
0544  00AE     MOVWF c
0545  082E     MOVF c, W
0546  07B2     ADDWF sign, F
72:            	sign = f1_as_plier >> 16;
0547  0828     MOVF f1, W
0548  00AE     MOVWF c
0549  0829     MOVF lval, W
054A  00AF     MOVWF f1
054B  082A     MOVF 0x2A, W
054C  00B0     MOVWF 0x30
054D  3010     MOVLW 0x10
054E  36B0     LSRF 0x30, F
054F  0CAF     RRF f1, F
0550  0CAE     RRF c, F
0551  0B89     DECFSZ WREG, F
0552  2D4E     GOTO 0x54E
0553  082E     MOVF c, W
0554  00B1     MOVWF 0x31
0555  0831     MOVF 0x31, W
0556  00B7     MOVWF sign
73:            	sign ^= (unsigned char)(f2_as_plicand >> 16);
0557  082B     MOVF f2, W
0558  00AE     MOVWF c
0559  082C     MOVF f2, W
055A  00AF     MOVWF f1
055B  082D     MOVF exp1, W
055C  00B0     MOVWF 0x30
055D  3010     MOVLW 0x10
055E  36B0     LSRF 0x30, F
055F  0CAF     RRF f1, F
0560  0CAE     RRF c, F
0561  0B89     DECFSZ WREG, F
0562  2D5E     GOTO 0x55E
0563  082E     MOVF c, W
0564  00B1     MOVWF 0x31
0565  0831     MOVF 0x31, W
0566  06B7     XORWF sign, F
74:            	sign &= 0x80;
0567  3080     MOVLW 0x80
0568  00AE     MOVWF c
0569  082E     MOVF c, W
056A  05B7     ANDWF sign, F
75:            	f1_as_plier |= 0x8000UL;
056B  17A9     BSF lval, 0x7
76:            	//f1_as_plier &= 0xFFFFUL;		// not required
77:            	f2_as_plicand |= 0x8000UL;
056C  17AC     BSF f2, 0x7
78:            	f2_as_plicand &= 0xFFFFUL;
056D  30FF     MOVLW 0xFF
056E  05AB     ANDWF f2, F
056F  30FF     MOVLW 0xFF
0570  05AC     ANDWF f2, F
0571  3000     MOVLW 0x0
0572  05AD     ANDWF exp1, F
79:            	f3_as_product = 0;
0573  3000     MOVLW 0x0
0574  00B3     MOVWF exp2
0575  3000     MOVLW 0x0
0576  00B4     MOVWF exp1
0577  3000     MOVLW 0x0
0578  00B5     MOVWF sign
80:            
81:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
82:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
83:            
84:            #define USE_SHRINK /* makes my test program smallest */
85:            
86:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
87:            /*
88:                     
89:            |seeeeeee|emmmmmmm|mmmmmmmm|
90:                     1.mmmmmmm mmmmmmmm
91:            
92:            a 16-bit multiply can be decomposed into the sum of four 8-bit multiplies
93:                   a  b
94:            *      c  d
95:            -----------
96:               ac| 0  0
97:                 |bc  0
98:                 |ad  0
99:            +    |   bd (we must not ignore this intermediate product
100:                        because it /can/ affect the high 16 bits of the result)
101:           ===========
102:            */
103:           	f1_as_plier &= 0xFFFFUL; /* required (see comment above) for this method */
104:           
105:                   f3_as_product  = ((unsigned int)LOWBYTE(f1_as_plier) * LOWBYTE(f2_as_plicand)) >> 8;
106:                   f3_as_product += (unsigned int)LOWBYTE(f1_as_plier) * HIGHBYTE(f2_as_plicand);
107:                   f3_as_product += (unsigned int)HIGHBYTE(f1_as_plier) * LOWBYTE(f2_as_plicand);
108:           #if defined(USE_MASKS)
109:                   f3_as_product += ((__uint24)
110:           			  ((unsigned int)HIGHBYTE(f1_as_plier) * HIGHBYTE(f2_as_plicand)))
111:           		<< 8;
112:           #elif defined(USE_SHRINK)
113:           	*((unsigned int*)(((unsigned char*)&f3_as_product)+1)) +=
114:           		(unsigned int)HIGHBYTE(f1_as_plier) * HIGHBYTE(f2_as_plicand);
115:           #else
116:           #error No method chosen
117:           #endif
118:           
119:           /*
120:           assuming normalized mantissa:
121:           smallest ac: 0x80 x 0x80 == 0x4000 .. shift down 7 bits
122:           largest ac:  0xff x 0xff == 0xfe01 .. shift down 8
123:            */
124:           	/* ensure result is normalized as expected by pack() */
125:           	if (f3_as_product & 0x800000u) {
126:           		f3_as_product >>= 1;
127:           		exp++;
128:           	}
129:           	f3_as_product >>= 1;
130:           
131:           #else
132:           	/* f1 & 0x8000 == 0x8000 */
133:           	/* f2 & 0x8000 == 0x8000 */
134:           	cntr = 7;
0579  3007     MOVLW 0x7
057A  00AE     MOVWF c
057B  082E     MOVF c, W
057C  00B6     MOVWF cntr
135:           	do {
136:           		if(f1_as_plier & 1)
057D  1C28     BTFSS f1, 0x0
057E  2D80     GOTO 0x580
057F  2D81     GOTO 0x581
0580  2D87     GOTO 0x587
137:           			f3_as_product += f2_as_plicand;
0581  082B     MOVF f2, W
0582  07B3     ADDWF exp2, F
0583  082C     MOVF f2, W
0584  3DB4     ADDWFC exp1, F
0585  082D     MOVF exp1, W
0586  3DB5     ADDWFC sign, F
138:           		f1_as_plier >>= 1;
0587  3001     MOVLW 0x1
0588  36AA     LSRF 0x2A, F
0589  0CA9     RRF lval, F
058A  0CA8     RRF f1, F
058B  0B89     DECFSZ WREG, F
058C  2D88     GOTO 0x588
139:           		f2_as_plicand <<= 1;
058D  3001     MOVLW 0x1
058E  35AB     LSLF f2, F
058F  0DAC     RLF f2, F
0590  0DAD     RLF exp1, F
0591  0B89     DECFSZ WREG, F
0592  2D8E     GOTO 0x58E
140:           	} while(--cntr != 0);
0593  3001     MOVLW 0x1
0594  02B6     SUBWF cntr, F
0595  1D03     BTFSS STATUS, 0x2
0596  2D98     GOTO 0x598
0597  2D99     GOTO 0x599
0598  2D7D     GOTO 0x57D
141:           	/* f1 & 0x100 == 0x100 */
142:           	/* f2 & 0x400000 == 0x400000 */
143:           	cntr = 9;
0599  3009     MOVLW 0x9
059A  00AE     MOVWF c
059B  082E     MOVF c, W
059C  00B6     MOVWF cntr
144:           	do {
145:           		if(f1_as_plier & 1)
059D  1C28     BTFSS f1, 0x0
059E  2DA0     GOTO 0x5A0
059F  2DA1     GOTO 0x5A1
05A0  2DA7     GOTO 0x5A7
146:           			f3_as_product += f2_as_plicand;
05A1  082B     MOVF f2, W
05A2  07B3     ADDWF exp2, F
05A3  082C     MOVF f2, W
05A4  3DB4     ADDWFC exp1, F
05A5  082D     MOVF exp1, W
05A6  3DB5     ADDWFC sign, F
147:           		f1_as_plier >>= 1;
05A7  3001     MOVLW 0x1
05A8  36AA     LSRF 0x2A, F
05A9  0CA9     RRF lval, F
05AA  0CA8     RRF f1, F
05AB  0B89     DECFSZ WREG, F
05AC  2DA8     GOTO 0x5A8
148:           		f3_as_product >>= 1;
05AD  3001     MOVLW 0x1
05AE  36B5     LSRF sign, F
05AF  0CB4     RRF exp1, F
05B0  0CB3     RRF exp2, F
05B1  0B89     DECFSZ WREG, F
05B2  2DAE     GOTO 0x5AE
149:           	} while(--cntr != 0);
05B3  3001     MOVLW 0x1
05B4  02B6     SUBWF cntr, F
05B5  1D03     BTFSS STATUS, 0x2
05B6  2DB8     GOTO 0x5B8
05B7  2DB9     GOTO 0x5B9
05B8  2D9D     GOTO 0x59D
150:           	/* f1 == 0 */
151:           	/* f2 & 0x400000 == 0x400000 */
152:           	/* because the last bit of f1 _was_ set,
153:           	   f3 & 0x200000 == 0x200000 and
154:           	   f3 & 0xc00000 == 0 */
155:           #endif
156:           	return __ftpack(f3_as_product, exp, sign);
05B9  0833     MOVF exp2, W
05BA  00A0     MOVWF __pcstackBANK0
05BB  0834     MOVF exp1, W
05BC  00A1     MOVWF length
05BD  0835     MOVF sign, W
05BE  00A2     MOVWF data
05BF  0832     MOVF sign, W
05C0  00AE     MOVWF c
05C1  082E     MOVF c, W
05C2  00A3     MOVWF data
05C3  0837     MOVF sign, W
05C4  00AF     MOVWF f1
05C5  082F     MOVF f1, W
05C6  00A4     MOVWF sign
05C7  318F     MOVLP 0xF
05C8  2710     CALL 0x710
05C9  3185     MOVLP 0x5
05CA  0140     MOVLB 0x0
05CB  0820     MOVF __pcstackBANK0, W
05CC  00A8     MOVWF f1
05CD  0821     MOVF length, W
05CE  00A9     MOVWF lval
05CF  0822     MOVF data, W
05D0  00AA     MOVWF 0x2A
157:           }
05D1  0008     RETURN
158:           #endif
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/ftdiv.c  -------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_dividend	(*(__uint24 *)&f1)
11:            #define	f2_as_divisor	(*(__uint24 *)&f2)
12:            #define	f3_as_quot	(*(__uint24 *)&f3)
13:            
14:            // floating addition
15:            #ifdef _OLDLIB
16:            #define	cntr		sign2
17:            float
18:            #ifdef _PIC18
19:            __ftdiv(float f1, float f2)
20:            #else
21:            __ftdiv(float f2, float f1)
22:            #endif
23:            {
24:            	unsigned char	exp1, exp2, sign1, sign2;
25:            	float	f3;
26:            	
27:            	f3_as_quot = 0;
28:            	sign1 = __ftunpack(&f1_as_dividend, &exp1);
29:            	if(exp1 == 0)
30:            		return f3;
31:            	sign2 = __ftunpack(&f2_as_divisor, &exp2);
32:            	if(exp2 == 0)
33:            		return f3;
34:            	exp1 -= exp2-127+8;	// compute new exponent
35:            	sign1 ^= sign2;
36:            	cntr = 16+8;
37:            	do {
38:            		f3_as_quot <<= 1;
39:            		if(f1_as_dividend >= f2_as_divisor) {
40:            			f1_as_dividend -= f2_as_divisor;
41:            			f3_as_quot |= 1;
42:            		}
43:            		f1_as_dividend <<= 1;
44:            	} while(--cntr != 0);
45:            	__ftpack(&f3_as_quot, exp1);
46:            	if(sign1)
47:            		f3_as_quot |= 0x800000;
48:            	return f3;
49:            }
50:            #else
51:            #define	exp2	sign
52:            float
53:            #ifdef _PIC18
54:            __ftdiv(float f1, float f2)
55:            #else
56:            __ftdiv(float f2, float f1)
57:            #endif
58:            {
59:            	unsigned char	exp, sign, cntr;
60:            	float	f3;
61:            	
62:            	// unpack the operands
63:            	if((exp = f1_as_dividend >> 15) == 0)
05D2  0140     MOVLB 0x0
05D3  082F     MOVF f1, W
05D4  00B2     MOVWF sign
05D5  0830     MOVF 0x30, W
05D6  00B3     MOVWF exp2
05D7  0831     MOVF 0x31, W
05D8  00B4     MOVWF exp1
05D9  1003     BCF STATUS, 0x0
05DA  0D33     RLF exp2, W
05DB  0D34     RLF exp1, W
05DC  00B5     MOVWF sign
05DD  0835     MOVF sign, W
05DE  00B7     MOVWF sign
05DF  0837     MOVF sign, W
05E0  1D03     BTFSS STATUS, 0x2
05E1  2DE3     GOTO 0x5E3
05E2  2DE4     GOTO 0x5E4
05E3  2DEB     GOTO 0x5EB
64:            		return 0.0;
05E4  3000     MOVLW 0x0
05E5  00AC     MOVWF f2
05E6  3000     MOVLW 0x0
05E7  00AD     MOVWF exp1
05E8  3000     MOVLW 0x0
05E9  00AE     MOVWF c
05EA  2E83     GOTO 0x683
65:            	if((exp2 = f2_as_divisor >> 15) == 0)
05EB  082C     MOVF f2, W
05EC  00B2     MOVWF sign
05ED  082D     MOVF exp1, W
05EE  00B3     MOVWF exp2
05EF  082E     MOVF c, W
05F0  00B4     MOVWF exp1
05F1  1003     BCF STATUS, 0x0
05F2  0D33     RLF exp2, W
05F3  0D34     RLF exp1, W
05F4  00B5     MOVWF sign
05F5  0835     MOVF sign, W
05F6  00BB     MOVWF sign
05F7  083B     MOVF sign, W
05F8  1D03     BTFSS STATUS, 0x2
05F9  2DFB     GOTO 0x5FB
05FA  2DFC     GOTO 0x5FC
05FB  2E03     GOTO 0x603
66:            		return 0.0;
05FC  3000     MOVLW 0x0
05FD  00AC     MOVWF f2
05FE  3000     MOVLW 0x0
05FF  00AD     MOVWF exp1
0600  3000     MOVLW 0x0
0601  00AE     MOVWF c
0602  2E83     GOTO 0x683
67:            	f3_as_quot = 0;
0603  3000     MOVLW 0x0
0604  00B8     MOVWF f3
0605  3000     MOVLW 0x0
0606  00B9     MOVWF 0x39
0607  3000     MOVLW 0x0
0608  00BA     MOVWF i
68:            	exp -= exp2-127+8;	// compute new exponent
0609  3089     MOVLW 0x89
060A  073B     ADDWF sign, W
060B  00B2     MOVWF sign
060C  0832     MOVF sign, W
060D  02B7     SUBWF sign, F
69:            	sign = f1_as_dividend >> 16;
060E  082F     MOVF f1, W
060F  00B2     MOVWF sign
0610  0830     MOVF 0x30, W
0611  00B3     MOVWF exp2
0612  0831     MOVF 0x31, W
0613  00B4     MOVWF exp1
0614  3010     MOVLW 0x10
0615  36B4     LSRF exp1, F
0616  0CB3     RRF exp2, F
0617  0CB2     RRF sign, F
0618  0B89     DECFSZ WREG, F
0619  2E15     GOTO 0x615
061A  0832     MOVF sign, W
061B  00B5     MOVWF sign
061C  0835     MOVF sign, W
061D  00BB     MOVWF sign
70:            	sign ^= (unsigned char)(f2_as_divisor >> 16);
061E  082C     MOVF f2, W
061F  00B2     MOVWF sign
0620  082D     MOVF exp1, W
0621  00B3     MOVWF exp2
0622  082E     MOVF c, W
0623  00B4     MOVWF exp1
0624  3010     MOVLW 0x10
0625  36B4     LSRF exp1, F
0626  0CB3     RRF exp2, F
0627  0CB2     RRF sign, F
0628  0B89     DECFSZ WREG, F
0629  2E25     GOTO 0x625
062A  0832     MOVF sign, W
062B  00B5     MOVWF sign
062C  0835     MOVF sign, W
062D  06BB     XORWF sign, F
71:            	sign &= 0x80;
062E  3080     MOVLW 0x80
062F  00B2     MOVWF sign
0630  0832     MOVF sign, W
0631  05BB     ANDWF sign, F
72:            	f1_as_dividend |= 0x8000UL;
0632  17B0     BSF 0x30, 0x7
73:            	f1_as_dividend &= 0xFFFFUL;
0633  30FF     MOVLW 0xFF
0634  05AF     ANDWF f1, F
0635  30FF     MOVLW 0xFF
0636  05B0     ANDWF 0x30, F
0637  3000     MOVLW 0x0
0638  05B1     ANDWF 0x31, F
74:            	f2_as_divisor |= 0x8000UL;
0639  17AD     BSF exp1, 0x7
75:            	f2_as_divisor &= 0xFFFFUL;
063A  30FF     MOVLW 0xFF
063B  05AC     ANDWF f2, F
063C  30FF     MOVLW 0xFF
063D  05AD     ANDWF exp1, F
063E  3000     MOVLW 0x0
063F  05AE     ANDWF c, F
76:            	cntr = 16+8;
0640  3018     MOVLW 0x18
0641  00B2     MOVWF sign
0642  0832     MOVF sign, W
0643  00B6     MOVWF cntr
77:            	do {
78:            		f3_as_quot <<= 1;
0644  3001     MOVLW 0x1
0645  35B8     LSLF f3, F
0646  0DB9     RLF 0x39, F
0647  0DBA     RLF i, F
0648  0B89     DECFSZ WREG, F
0649  2E45     GOTO 0x645
79:            		if(f1_as_dividend >= f2_as_divisor) {
064A  082E     MOVF c, W
064B  0231     SUBWF 0x31, W
064C  1D03     BTFSS STATUS, 0x2
064D  2E54     GOTO 0x654
064E  082D     MOVF exp1, W
064F  0230     SUBWF 0x30, W
0650  1D03     BTFSS STATUS, 0x2
0651  2E54     GOTO 0x654
0652  082C     MOVF f2, W
0653  022F     SUBWF f1, W
0654  1C03     BTFSS STATUS, 0x0
0655  2E57     GOTO 0x657
0656  2E58     GOTO 0x658
0657  2E5F     GOTO 0x65F
80:            			f1_as_dividend -= f2_as_divisor;
0658  082C     MOVF f2, W
0659  02AF     SUBWF f1, F
065A  082D     MOVF exp1, W
065B  3BB0     SUBWFB 0x30, F
065C  082E     MOVF c, W
065D  3BB1     SUBWFB 0x31, F
81:            			f3_as_quot |= 1;
065E  1438     BSF f3, 0x0
82:            		}
83:            		f1_as_dividend <<= 1;
065F  3001     MOVLW 0x1
0660  35AF     LSLF f1, F
0661  0DB0     RLF 0x30, F
0662  0DB1     RLF 0x31, F
0663  0B89     DECFSZ WREG, F
0664  2E60     GOTO 0x660
84:            	} while(--cntr != 0);
0665  3001     MOVLW 0x1
0666  02B6     SUBWF cntr, F
0667  1D03     BTFSS STATUS, 0x2
0668  2E6A     GOTO 0x66A
0669  2E6B     GOTO 0x66B
066A  2E44     GOTO 0x644
85:            	return __ftpack(f3_as_quot, exp, sign);
066B  0838     MOVF f3, W
066C  00A0     MOVWF __pcstackBANK0
066D  0839     MOVF 0x39, W
066E  00A1     MOVWF length
066F  083A     MOVF i, W
0670  00A2     MOVWF data
0671  0837     MOVF sign, W
0672  00B2     MOVWF sign
0673  0832     MOVF sign, W
0674  00A3     MOVWF data
0675  083B     MOVF sign, W
0676  00B3     MOVWF exp2
0677  0833     MOVF exp2, W
0678  00A4     MOVWF sign
0679  318F     MOVLP 0xF
067A  2710     CALL 0x710
067B  3185     MOVLP 0x5
067C  0140     MOVLB 0x0
067D  0820     MOVF __pcstackBANK0, W
067E  00AC     MOVWF f2
067F  0821     MOVF length, W
0680  00AD     MOVWF exp1
0681  0822     MOVF data, W
0682  00AE     MOVWF c
86:            }
0683  0008     RETURN
87:            #endif	
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/ftadd.c  -------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(__uint24 *)&f1)
11:            #define	f2_as_mant2	(*(__uint24 *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            float
16:            __ftadd(float f1, float f2)
17:            {
18:            	unsigned char	exp1, exp2, sign1, sign2, cntr;
19:            	
20:            	if(sizeof(f1_as_mant1) != 3)
21:            		return 0;
22:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
23:            	if(exp1 == 0)
24:            		return f2;
25:            	sign2 = __ftunpack(&f2_as_mant2, &exp2);
26:            	if(exp2 != 0) {
27:            		cntr = 6;
28:            		// determine the smaller number. 
29:            		if(exp1 < exp2) {
30:            			if((unsigned char)(exp2-exp1) > sizeof(f1)*8) {
31:            				// return f2
32:            				f1_as_mant1 = 0;
33:            				exp1 = exp2;
34:            				sign1 = sign2;
35:            			} else {
36:            				// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
37:            				// left, decrementing exp2.
38:            				do {
39:            					f2_as_mant2 <<= 1;
40:            					exp2--;
41:            				} while(exp2 != exp1 && --cntr != 0);
42:            				while(exp1 != exp2) {
43:            					f1_as_mant1 >>= 1;
44:            					exp1++;
45:            				}
46:            			}
47:            		} else if(exp1 != exp2) {
48:            			if((unsigned char)(exp1-exp2) > sizeof(f1)*8)
49:            				f2_as_mant2 = 0;
50:            			else {
51:            				// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
52:            				// left, decrementing exp2.
53:            				do {
54:            					f1_as_mant1 <<= 1;
55:            					exp1--;
56:            				} while(exp2 != exp1 && --cntr != 0);
57:            				while(exp1 != exp2) {
58:            					f2_as_mant2 >>= 1;
59:            					exp2++;
60:            				}
61:            			}
62:            		}
63:            		if(sign1 != 0) { 
64:            			f1_as_mant1 ^= 0xFFFFFF;
65:            			f1_as_mant1++;
66:            		}
67:            		if(sign2 != 0) {
68:            			f2_as_mant2 ^= 0xFFFFFF;
69:            			f2_as_mant2++;
70:            		}
71:            		sign1 = 0;
72:            		f1_as_mant1 += f2_as_mant2;
73:            		if(f1_as_mant1 & 0x800000) {
74:            			f1_as_mant1 ^= 0xFFFFFF;
75:            			f1_as_mant1++;
76:            			sign1 = 1;
77:            		}
78:            	}
79:            	__ftpack(&f1_as_mant1, exp1);
80:            	if(sign1)
81:            		f1_as_mant1 ^= 0x800000;
82:            	return f1;
83:            }
84:            #else
85:            float
86:            __ftadd(float f1, float f2)
87:            {
88:            	unsigned char	exp1, exp2, sign;
89:            
90:            	exp1 = f1_as_mant1 >> 15;
0204  0140     MOVLB 0x0
0205  0828     MOVF f1, W
0206  00AE     MOVWF c
0207  0829     MOVF lval, W
0208  00AF     MOVWF f1
0209  082A     MOVF 0x2A, W
020A  00B0     MOVWF 0x30
020B  1003     BCF STATUS, 0x0
020C  0D2F     RLF f1, W
020D  0D30     RLF 0x30, W
020E  00B1     MOVWF 0x31
020F  0831     MOVF 0x31, W
0210  00B4     MOVWF exp1
91:            	exp2 = f2_as_mant2 >> 15;
0211  082B     MOVF f2, W
0212  00AE     MOVWF c
0213  082C     MOVF f2, W
0214  00AF     MOVWF f1
0215  082D     MOVF exp1, W
0216  00B0     MOVWF 0x30
0217  1003     BCF STATUS, 0x0
0218  0D2F     RLF f1, W
0219  0D30     RLF 0x30, W
021A  00B1     MOVWF 0x31
021B  0831     MOVF 0x31, W
021C  00B3     MOVWF exp2
92:            	if(exp1 == 0 || exp1 < exp2  && (unsigned char)(exp2-exp1) > sizeof(f1)*8)
021D  0834     MOVF exp1, W
021E  1903     BTFSC STATUS, 0x2
021F  2A21     GOTO 0x221
0220  2A22     GOTO 0x222
0221  2A32     GOTO 0x232
0222  0833     MOVF exp2, W
0223  0234     SUBWF exp1, W
0224  1803     BTFSC STATUS, 0x0
0225  2A27     GOTO 0x227
0226  2A28     GOTO 0x228
0227  2A39     GOTO 0x239
0228  0833     MOVF exp2, W
0229  00AE     MOVWF c
022A  0834     MOVF exp1, W
022B  02AE     SUBWF c, F
022C  3019     MOVLW 0x19
022D  022E     SUBWF c, W
022E  1C03     BTFSS STATUS, 0x0
022F  2A31     GOTO 0x231
0230  2A32     GOTO 0x232
0231  2A39     GOTO 0x239
93:            		return f2;
0232  082B     MOVF f2, W
0233  00A8     MOVWF f1
0234  082C     MOVF f2, W
0235  00A9     MOVWF lval
0236  082D     MOVF exp1, W
0237  00AA     MOVWF 0x2A
0238  2B23     GOTO 0x323
94:            	if(exp2 == 0 || exp1 > exp2  && (unsigned char)(exp1-exp2) > sizeof(f1)*8)
0239  0833     MOVF exp2, W
023A  1903     BTFSC STATUS, 0x2
023B  2A3D     GOTO 0x23D
023C  2A3E     GOTO 0x23E
023D  2A4E     GOTO 0x24E
023E  0834     MOVF exp1, W
023F  0233     SUBWF exp2, W
0240  1803     BTFSC STATUS, 0x0
0241  2A43     GOTO 0x243
0242  2A44     GOTO 0x244
0243  2A4F     GOTO 0x24F
0244  0834     MOVF exp1, W
0245  00AE     MOVWF c
0246  0833     MOVF exp2, W
0247  02AE     SUBWF c, F
0248  3019     MOVLW 0x19
0249  022E     SUBWF c, W
024A  1C03     BTFSS STATUS, 0x0
024B  2A4D     GOTO 0x24D
024C  2A4E     GOTO 0x24E
024D  2A4F     GOTO 0x24F
95:            		return f1;
024E  2B23     GOTO 0x323
96:            	sign = 6;
024F  3006     MOVLW 0x6
0250  00AE     MOVWF c
0251  082E     MOVF c, W
0252  00B2     MOVWF sign
97:            	if(f1_as_mant1 & 0x800000L)
0253  1FAA     BTFSS 0x2A, 0x7
0254  2A56     GOTO 0x256
0255  2A57     GOTO 0x257
0256  2A58     GOTO 0x258
98:            		sign |= 0x80;
0257  17B2     BSF sign, 0x7
99:            	if(f2_as_mant2 & 0x800000L)
0258  1FAD     BTFSS exp1, 0x7
0259  2A5B     GOTO 0x25B
025A  2A5C     GOTO 0x25C
025B  2A5D     GOTO 0x25D
100:           		sign |= 0x40;
025C  1732     BSF sign, 0x6
101:           	f1_as_mant1 |= 0x8000UL;
025D  17A9     BSF lval, 0x7
102:           	f1_as_mant1 &= 0xFFFFUL;
025E  30FF     MOVLW 0xFF
025F  05A8     ANDWF f1, F
0260  30FF     MOVLW 0xFF
0261  05A9     ANDWF lval, F
0262  3000     MOVLW 0x0
0263  05AA     ANDWF 0x2A, F
103:           	f2_as_mant2 |= 0x8000UL;
0264  17AC     BSF f2, 0x7
104:           	f2_as_mant2 &= 0xFFFFUL;
0265  30FF     MOVLW 0xFF
0266  05AB     ANDWF f2, F
0267  30FF     MOVLW 0xFF
0268  05AC     ANDWF f2, F
0269  3000     MOVLW 0x0
026A  05AD     ANDWF exp1, F
105:           	// determine the smaller number. 
106:           	if(exp1 < exp2) {
026B  0833     MOVF exp2, W
026C  0234     SUBWF exp1, W
026D  1803     BTFSC STATUS, 0x0
026E  2A70     GOTO 0x270
026F  2A71     GOTO 0x271
0270  2A99     GOTO 0x299
107:           		// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
108:           		// left, decrementing exp2.
109:           		do {
110:           			f2_as_mant2 <<= 1;
0271  3001     MOVLW 0x1
0272  35AB     LSLF f2, F
0273  0DAC     RLF f2, F
0274  0DAD     RLF exp1, F
0275  0B89     DECFSZ WREG, F
0276  2A72     GOTO 0x272
111:           			exp2--;
0277  3001     MOVLW 0x1
0278  02B3     SUBWF exp2, F
112:           		} while(exp2 != exp1 && --sign & 7);
0279  0833     MOVF exp2, W
027A  0634     XORWF exp1, W
027B  1903     BTFSC STATUS, 0x2
027C  2A7E     GOTO 0x27E
027D  2A7F     GOTO 0x27F
027E  2A92     GOTO 0x292
027F  3001     MOVLW 0x1
0280  02B2     SUBWF sign, F
0281  0832     MOVF sign, W
0282  3907     ANDLW 0x7
0283  1D03     BTFSS STATUS, 0x2
0284  2A86     GOTO 0x286
0285  2A87     GOTO 0x287
0286  2A71     GOTO 0x271
0287  2A92     GOTO 0x292
113:           		while(exp1 != exp2) {
0292  0834     MOVF exp1, W
0293  0633     XORWF exp2, W
0294  1D03     BTFSS STATUS, 0x2
0295  2A97     GOTO 0x297
0296  2A98     GOTO 0x298
0297  2A88     GOTO 0x288
0298  2AC6     GOTO 0x2C6
114:           			f1_as_mant1 >>= 1;
0288  3001     MOVLW 0x1
0289  36AA     LSRF 0x2A, F
028A  0CA9     RRF lval, F
028B  0CA8     RRF f1, F
028C  0B89     DECFSZ WREG, F
028D  2A89     GOTO 0x289
115:           			exp1++;
028E  3001     MOVLW 0x1
028F  00AE     MOVWF c
0290  082E     MOVF c, W
0291  07B4     ADDWF exp1, F
116:           		}
117:           	} else if(exp1 > exp2) {
0299  0834     MOVF exp1, W
029A  0233     SUBWF exp2, W
029B  1803     BTFSC STATUS, 0x0
029C  2A9E     GOTO 0x29E
029D  2A9F     GOTO 0x29F
029E  2AC6     GOTO 0x2C6
118:           		// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
119:           		// left, decrementing exp2.
120:           		do {
121:           			f1_as_mant1 <<= 1;
029F  3001     MOVLW 0x1
02A0  35A8     LSLF f1, F
02A1  0DA9     RLF lval, F
02A2  0DAA     RLF 0x2A, F
02A3  0B89     DECFSZ WREG, F
02A4  2AA0     GOTO 0x2A0
122:           			exp1--;
02A5  3001     MOVLW 0x1
02A6  02B4     SUBWF exp1, F
123:           		} while(exp2 != exp1 && --sign & 7);
02A7  0833     MOVF exp2, W
02A8  0634     XORWF exp1, W
02A9  1903     BTFSC STATUS, 0x2
02AA  2AAC     GOTO 0x2AC
02AB  2AAD     GOTO 0x2AD
02AC  2AC0     GOTO 0x2C0
02AD  3001     MOVLW 0x1
02AE  02B2     SUBWF sign, F
02AF  0832     MOVF sign, W
02B0  3907     ANDLW 0x7
02B1  1D03     BTFSS STATUS, 0x2
02B2  2AB4     GOTO 0x2B4
02B3  2AB5     GOTO 0x2B5
02B4  2A9F     GOTO 0x29F
02B5  2AC0     GOTO 0x2C0
124:           		while(exp1 != exp2) {
02C0  0834     MOVF exp1, W
02C1  0633     XORWF exp2, W
02C2  1D03     BTFSS STATUS, 0x2
02C3  2AC5     GOTO 0x2C5
02C4  2AC6     GOTO 0x2C6
02C5  2AB6     GOTO 0x2B6
125:           			f2_as_mant2 >>= 1;
02B6  3001     MOVLW 0x1
02B7  36AD     LSRF exp1, F
02B8  0CAC     RRF f2, F
02B9  0CAB     RRF f2, F
02BA  0B89     DECFSZ WREG, F
02BB  2AB7     GOTO 0x2B7
126:           			exp2++;
02BC  3001     MOVLW 0x1
02BD  00AE     MOVWF c
02BE  082E     MOVF c, W
02BF  07B3     ADDWF exp2, F
127:           		}
128:           	}
129:           	if(sign & 0x80) { 
02C6  1FB2     BTFSS sign, 0x7
02C7  2AC9     GOTO 0x2C9
02C8  2ACA     GOTO 0x2CA
02C9  2ADA     GOTO 0x2DA
130:           		// complement and add 1
131:           		f1_as_mant1 ^= 0xFFFFFFUL;
02CA  30FF     MOVLW 0xFF
02CB  06A8     XORWF f1, F
02CC  30FF     MOVLW 0xFF
02CD  06A9     XORWF lval, F
02CE  30FF     MOVLW 0xFF
02CF  06AA     XORWF 0x2A, F
132:           		f1_as_mant1++;
02D0  3001     MOVLW 0x1
02D1  07A8     ADDWF f1, F
02D2  3000     MOVLW 0x0
02D3  1803     BTFSC STATUS, 0x0
02D4  3001     MOVLW 0x1
02D5  07A9     ADDWF lval, F
02D6  3000     MOVLW 0x0
02D7  1803     BTFSC STATUS, 0x0
02D8  3001     MOVLW 0x1
02D9  07AA     ADDWF 0x2A, F
133:           	}
134:           	if(sign & 0x40) {
02DA  1F32     BTFSS sign, 0x6
02DB  2ADD     GOTO 0x2DD
02DC  2ADE     GOTO 0x2DE
02DD  2AEE     GOTO 0x2EE
135:           		// complement and add 1
136:           		f2_as_mant2 ^= 0xFFFFFFUL;
02DE  30FF     MOVLW 0xFF
02DF  06AB     XORWF f2, F
02E0  30FF     MOVLW 0xFF
02E1  06AC     XORWF f2, F
02E2  30FF     MOVLW 0xFF
02E3  06AD     XORWF exp1, F
137:           		f2_as_mant2++;
02E4  3001     MOVLW 0x1
02E5  07AB     ADDWF f2, F
02E6  3000     MOVLW 0x0
02E7  1803     BTFSC STATUS, 0x0
02E8  3001     MOVLW 0x1
02E9  07AC     ADDWF f2, F
02EA  3000     MOVLW 0x0
02EB  1803     BTFSC STATUS, 0x0
02EC  3001     MOVLW 0x1
02ED  07AD     ADDWF exp1, F
138:           	}
139:           	sign = 0;
02EE  01B2     CLRF sign
140:           	f2_as_mant2 += f1_as_mant1;
02EF  0828     MOVF f1, W
02F0  07AB     ADDWF f2, F
02F1  0829     MOVF lval, W
02F2  3DAC     ADDWFC f2, F
02F3  082A     MOVF 0x2A, W
02F4  3DAD     ADDWFC exp1, F
141:           	if(f2_as_mant2 & 0x800000UL) {
02F5  1FAD     BTFSS exp1, 0x7
02F6  2AF8     GOTO 0x2F8
02F7  2AF9     GOTO 0x2F9
02F8  2B0B     GOTO 0x30B
142:           		f2_as_mant2 ^= 0xFFFFFFUL;
02F9  30FF     MOVLW 0xFF
02FA  06AB     XORWF f2, F
02FB  30FF     MOVLW 0xFF
02FC  06AC     XORWF f2, F
02FD  30FF     MOVLW 0xFF
02FE  06AD     XORWF exp1, F
143:           		f2_as_mant2++;
02FF  3001     MOVLW 0x1
0300  07AB     ADDWF f2, F
0301  3000     MOVLW 0x0
0302  1803     BTFSC STATUS, 0x0
0303  3001     MOVLW 0x1
0304  07AC     ADDWF f2, F
0305  3000     MOVLW 0x0
0306  1803     BTFSC STATUS, 0x0
0307  3001     MOVLW 0x1
0308  07AD     ADDWF exp1, F
144:           		sign = 1;
0309  01B2     CLRF sign
030A  0AB2     INCF sign, F
145:           	}
146:           	return __ftpack(f2_as_mant2, exp1, sign);
030B  082B     MOVF f2, W
030C  00A0     MOVWF __pcstackBANK0
030D  082C     MOVF f2, W
030E  00A1     MOVWF length
030F  082D     MOVF exp1, W
0310  00A2     MOVWF data
0311  0834     MOVF exp1, W
0312  00AE     MOVWF c
0313  082E     MOVF c, W
0314  00A3     MOVWF data
0315  0832     MOVF sign, W
0316  00AF     MOVWF f1
0317  082F     MOVF f1, W
0318  00A4     MOVWF sign
0319  318F     MOVLP 0xF
031A  2710     CALL 0x710
031B  3182     MOVLP 0x2
031C  0140     MOVLB 0x0
031D  0820     MOVF __pcstackBANK0, W
031E  00A8     MOVWF f1
031F  0821     MOVF length, W
0320  00A9     MOVWF lval
0321  0822     MOVF data, W
0322  00AA     MOVWF 0x2A
147:           
148:           }
0323  0008     RETURN
149:           #endif
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/frexp.c  -------------------------------
1:             /*	Frexp/ldexp in C */
2:             #include <math.h>
3:             #include <float.h>
4:             #include <errno.h>
5:             
6:             
7:             /* PIC32 definition */
8:             #ifdef __PICC32__
9:             #if	__SIZEOF_DOUBLE__ == 4
10:            #define	EXCESS	126
11:            #define MAX_EXPONENT 255
12:            #define __STRUCT32
13:            typedef union both
14:            {
15:            	struct flt
16:            	{
17:            		unsigned 	mant:16;
18:            		unsigned	hmant:7;
19:            		unsigned	exp:8;
20:            		unsigned	sign:1;
21:            	}	flt;
22:            	double	fl;
23:            } both_t;
24:            #endif /* end 32-bit floating point */
25:            
26:            #endif // __PICC32__
27:            
28:            /* ARM-C definition */
29:            #if defined(__ARMC__)
30:            /* For 32-bit floating point */
31:            #if	__SIZEOF_DOUBLE__ == 4
32:            #define	EXCESS	126
33:            #define MAX_EXPONENT 255
34:            #define __STRUCT32
35:            typedef union both
36:            {
37:            	struct flt
38:            	{
39:            		unsigned	sign:1;
40:            		unsigned	exp:8;
41:            		unsigned	hmant:7;
42:            		unsigned 	mant:16;
43:            	}	flt;
44:            	double	fl;
45:            } both_t;
46:            #endif /* end 32-bit floating point */
47:            #endif /* end ARM-C */
48:            
49:            /* PICC-18 definition */
50:            #if defined(__PICC18__) || defined(__PICCPRO__) || defined(__18CXX)
51:            /* For 32-bit floating point */
52:            #if	__SIZEOF_DOUBLE__ == 4
53:            #define	EXCESS	126
54:            #define MAX_EXPONENT 255
55:            #define __STRUCT32
56:            typedef union both
57:            {
58:            	struct flt
59:            	{
60:            		unsigned  char	mant[2];
61:            		unsigned	hmant:7;
62:            		unsigned	lexp:1;
63:            		unsigned	hexp:7;
64:            		unsigned	sign:1;
65:            	}	flt;
66:            	double	fl;
67:            } both_t;
68:            #endif /* end 32-bit floating point */
69:            #if	__SIZEOF_DOUBLE__ == 3
70:            #define	EXCESS	126
71:            #define MAX_EXPONENT 255
72:            #define __STRUCT24
73:            typedef union both
74:            {
75:            	struct flt
76:            	{
77:            		unsigned char 	mant[1];
78:            		unsigned	hmant:7;
79:            		unsigned	lexp:1;
80:            		unsigned	hexp:7;
81:            		unsigned	sign:1;
82:            	}	flt;
83:            	double	fl;
84:            } both_t;
85:            #endif /* end 24-bit floating point */
86:            #endif /* end PICC-18-C / PICC PRO */
87:            
88:            /* dsPICC definition */
89:            #if defined(__DSPICC__)
90:            /* For 32-bit floating point */
91:            #if	__SIZEOF_DOUBLE__ == 4
92:            #define	EXCESS	126
93:            #define MAX_EXPONENT 255
94:            #define __STRUCT32
95:            typedef union both
96:            {
97:            	struct flt
98:            	{
99:            		unsigned 	mant:16;
100:           		unsigned	sign:1;
101:           		unsigned	exp:8;
102:           		unsigned	hmant:7;
103:           	}	flt;
104:           	double	fl;
105:           } both_t;
106:           #endif /* end 32-bit floating point */
107:           #endif /* end dsPICC */
108:           
109:           /* PSOC definition */
110:           #if defined(_PSOC_)
111:           /* For 32-bit floating point */
112:           #if	__SIZEOF_DOUBLE__ == 4
113:           #define	EXCESS	126
114:           #define MAX_EXPONENT 255
115:           #define __STRUCT32
116:           typedef union both
117:           {
118:           	struct flt
119:           	{
120:           		unsigned	sign:1;
121:           		unsigned	exp:8;
122:           		unsigned	hmant:7;
123:           		unsigned char	mant[2];
124:           	}	flt;
125:           	double	fl;
126:           } both_t;
127:           #endif /* end 32-bit floating point */
128:           
129:           #if	__SIZEOF_DOUBLE__ == 3
130:           #define	EXCESS	126
131:           #define MAX_EXPONENT 255
132:           #define __STRUCT24
133:           typedef union both
134:           {
135:           	struct flt
136:           	{
137:           		unsigned	sign:1;
138:           		unsigned	exp:8;
139:           		unsigned	hmant:7;
140:           		unsigned char	mant[1];
141:           	}	flt;
142:           	double	fl;
143:           } both_t;
144:           #endif /* end 24-bit floating point */
145:           #endif /* end PSOC */
146:           
147:           
148:           /* MSP430 definition */
149:           #if defined(__MSP430C__)
150:           /* For 32-bit floating point */
151:           #if	__SIZEOF_DOUBLE__ == 4
152:           #define	EXCESS	126
153:           #define MAX_EXPONENT 255
154:           #define __STRUCT32
155:           typedef union both
156:           {
157:           	struct flt
158:           	{
159:           		unsigned char	mant[2];
160:           		unsigned	hmant:7;
161:           		unsigned	exp:8;
162:           		unsigned	sign:1;
163:           	}	flt;
164:           	double	fl;
165:           } both_t;
166:           #endif /* end 32-bit floating point */
167:           #endif /* end MSP430 */
168:           
169:           /* Z80 definition */
170:           #if	z80
171:           #if	__SIZEOF_DOUBLE__ == 4
172:           #define	EXCESS	64
173:           #define __STRUCT32
174:           typedef union both
175:           {
176:           	struct flt
177:           	{
178:           		unsigned char	mant[2];
179:           		unsigned	hmant:8;
180:           		unsigned	exp:7;
181:           		unsigned	sign:1;
182:           	}	flt;
183:           	double	fl;
184:           } both_t;
185:           #endif
186:           #endif	/* end Z80 */
187:           
188:           
189:           #if	__SIZEOF_DOUBLE__ == 4 && !defined(__STRUCT32)
190:           #warning Using generic 32-bit structure definition. A compiler-specific one should be defined
191:           #define __STRUCT32
192:           #if	defined(_XA_) || defined(i8096) || defined(i8086)
193:           #define	LITTLE_ENDIAN
194:           #endif
195:           
196:           typedef union both
197:           {
198:           	struct flt
199:           	{
200:           #define	EXCESS	126
201:           #define MAX_EXPONENT 255
202:           #ifdef	LITTLE_ENDIAN
203:           		unsigned char	mant[2];
204:           		unsigned	hmant:7;
205:           		unsigned	exp:8;
206:           		unsigned	sign:1;
207:           #else
208:           		unsigned	sign:1;
209:           		unsigned	exp:8;
210:           		unsigned	hmant:7;
211:           		unsigned char	mant[2];
212:           #endif
213:           	}	flt;
214:           	double	fl;
215:           } both_t;
216:           
217:           #endif
218:           
219:           
220:           #if	__SIZEOF_DOUBLE__ == 8 && !defined(__STRUCT64)
221:           #warning Using generic 64-bit structure definition. A compiler-specific one should be defined
222:           #define __STRUCT64
223:           #if	defined(_XA_) || defined(i8096) || defined(i8086)
224:           #define	LITTLE_ENDIAN
225:           #endif
226:           #define	EXCESS	1022
227:           #define MAX_EXPONENT 2047
228:           typedef union both
229:           {
230:           	struct flt
231:           	{
232:           #ifdef	LITTLE_ENDIAN
233:           		unsigned char	mant[6];
234:           		unsigned	hmant:4;
235:           		unsigned	exp:11;
236:           		unsigned	sign:1;
237:           #else
238:           		unsigned	sign:1;
239:           		unsigned	exp:11;
240:           		unsigned	hmant:4;
241:           		unsigned char	mant[6];
242:           #endif
243:           	}	flt;
244:           	double	fl;
245:           } both_t;
246:           #endif
247:           
248:           
249:           #if	!defined(__STRUCT32) && !defined(__STRUCT64) && !defined(__STRUCT24)
250:           #error No floating point structure definition created for this compiler
251:           #endif
252:           
253:           double
254:           frexp(double value, int * eptr)
255:           {
256:           	if (value == 0.0) {
0D44  0140     MOVLB 0x0
0D45  0822     MOVF data, W
0D46  0421     IORWF length, W
0D47  0420     IORWF __pcstackBANK0, W
0D48  1D03     BTFSS STATUS, 0x2
0D49  2D4B     GOTO 0x54B
0D4A  2D4C     GOTO 0x54C
0D4B  2D53     GOTO 0x553
257:           		*eptr = 0;
0D4C  0823     MOVF data, W
0D4D  0086     MOVWF FSR1
0D4E  0187     CLRF FSR1H
0D4F  3000     MOVLW 0x0
0D50  3FC0     MOVWI [0]FSR1
0D51  3FC1     MOVWI [1]FSR1
0D52  2D7B     GOTO 0x57B
258:           		return 0.0;
259:           	}
260:           #if defined(__PICC18__) || defined(__PICCPRO__) || defined(__18CXX)
261:           	*eptr = ((both_t *)&value)->flt.hexp << 1;
0D53  0822     MOVF data, W
0D54  397F     ANDLW 0x7F
0D55  00A4     MOVWF sign
0D56  01A5     CLRF p1
0D57  35A4     LSLF sign, F
0D58  0DA5     RLF p1, F
0D59  0823     MOVF data, W
0D5A  0086     MOVWF FSR1
0D5B  0187     CLRF FSR1H
0D5C  0824     MOVF sign, W
0D5D  3FC0     MOVWI [0]FSR1
0D5E  0825     MOVF p1, W
0D5F  3FC1     MOVWI [1]FSR1
262:           	*eptr |= ((both_t *)&value)->flt.lexp;
0D60  0D21     RLF length, W
0D61  0D21     RLF length, W
0D62  3901     ANDLW 0x1
0D63  00A4     MOVWF sign
0D64  01A5     CLRF p1
0D65  0823     MOVF data, W
0D66  0086     MOVWF FSR1
0D67  0187     CLRF FSR1H
0D68  0824     MOVF sign, W
0D69  0481     IORWF INDF1, F
0D6A  3141     ADDFSR 1, 1
0D6B  0825     MOVF p1, W
0D6C  0481     IORWF INDF1, F
263:           	*eptr -= EXCESS;
0D6D  0823     MOVF data, W
0D6E  0086     MOVWF FSR1
0D6F  0187     CLRF FSR1H
0D70  3082     MOVLW 0x82
0D71  0781     ADDWF INDF1, F
0D72  3141     ADDFSR 1, 1
0D73  30FF     MOVLW 0xFF
0D74  3D81     ADDWFC INDF1, F
0D75  317F     ADDFSR 1, -1
264:           #else
265:           	*eptr = ((both_t *)&value)->flt.exp - EXCESS;
266:           #endif
267:           #if defined(__PICC18__) || defined(__PICCPRO__) || defined(__18CXX)
268:           	((both_t *)&value)->flt.hexp = EXCESS >> 1;
0D76  0822     MOVF data, W
0D77  3980     ANDLW 0x80
0D78  383F     IORLW 0x3F
0D79  00A2     MOVWF data
269:           	((both_t *)&value)->flt.lexp = EXCESS & 0x01;
0D7A  13A1     BCF length, 0x7
270:           #else
271:           	((both_t *)&value)->flt.exp = EXCESS;
272:           #endif
273:           	return value;
274:           }
0D7B  0008     RETURN
275:           
276:           double
277:           ldexp(double value, int newexp)
278:           {
279:           	if (value == 0.0)
280:           		return 0.0;
281:           #if defined(__PICC18__) || defined(__PICCPRO__) || defined(__18CXX)
282:           	newexp += ((both_t *)&value)->flt.hexp << 1;
283:           	newexp += ((both_t *)&value)->flt.lexp;
284:           #else
285:           	newexp += ((both_t *)&value)->flt.exp;
286:           #endif
287:           	if (newexp < 0) {
288:           		errno = ERANGE;
289:           		return 0.0;
290:           	}
291:           	else if (newexp > MAX_EXPONENT) {
292:           		errno = ERANGE;
293:           		if (value < 0.0)
294:           			return -DBL_MAX;
295:           		else
296:           			return DBL_MAX;
297:           	}
298:           	else {
299:           #if defined(__PICC18__) || defined(__PICCPRO__) || defined(__18CXX)
300:           		((both_t *)&value)->flt.hexp = newexp >> 1;
301:           		((both_t *)&value)->flt.lexp = newexp & 0x01;
302:           #else
303:           		((both_t *)&value)->flt.exp = newexp;
304:           #endif
305:           	}
306:           	return value;
307:           }
308:           
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/float.c  -------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             #include	"ftarith.h"
7:             
8:             
9:             //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:            //	and return the sign (zero is positive)
11:            
12:            #ifdef _OLDLIB
13:            
14:            unsigned char
15:            __ftunpack(__uint24 * arg, unsigned char * exp)
16:            {
17:            	unsigned char	sign;
18:            
19:            	*exp = sign = *arg >> 15;
20:            	if(sign == 0) {
21:            		*arg = 0;
22:            		return 0;
23:            	}
24:            	sign = 0;
25:            	*arg |= 0x8000;
26:            	if(*arg & 0x800000)
27:            		sign++;
28:            	*arg &= 0xFFFF;
29:            	return sign;
30:            }
31:            
32:            // normalize and pack the supplied argument into floating point format
33:            
34:            void
35:            __ftpack(__uint24 * arg, unsigned char exp)
36:            {
37:            	if(exp == 0 || *arg == 0) {
38:            		*arg = 0;
39:            		return;
40:            	}
41:            	while(*arg & 0xFE0000UL) {
42:            		exp++;
43:            		*arg >>= 1;
44:            	}
45:            	while(*arg & 0xFF0000UL) {
46:            		exp++;
47:            		(*arg)++;
48:            		*arg >>= 1;
49:            	}
50:            	while(!(*arg & 0x8000UL)) {
51:            		exp--;
52:            		*arg <<= 1;
53:            	}
54:            	if(!(exp & 1))
55:            		*arg &= ~0x8000L;
56:            	exp >>= 1;
57:            	*arg |= (__uint24)exp << 16;
58:            }
59:            
60:            #else
61:            float
62:            __ftpack(__uint24 arg, unsigned char exp, unsigned char sign)
63:            {
64:            	if(exp == 0 || arg == 0)
0F10  0140     MOVLB 0x0
0F11  0823     MOVF data, W
0F12  1903     BTFSC STATUS, 0x2
0F13  2F15     GOTO 0x715
0F14  2F16     GOTO 0x716
0F15  2F1D     GOTO 0x71D
0F16  0822     MOVF data, W
0F17  0421     IORWF length, W
0F18  0420     IORWF __pcstackBANK0, W
0F19  1D03     BTFSS STATUS, 0x2
0F1A  2F1C     GOTO 0x71C
0F1B  2F1D     GOTO 0x71D
0F1C  2F2E     GOTO 0x72E
65:            		return 0.0;
0F1D  3000     MOVLW 0x0
0F1E  00A0     MOVWF __pcstackBANK0
0F1F  3000     MOVLW 0x0
0F20  00A1     MOVWF length
0F21  3000     MOVLW 0x0
0F22  00A2     MOVWF data
0F23  2F84     GOTO 0x784
66:            	while(arg & 0xFE0000UL) {
0F2E  30FE     MOVLW 0xFE
0F2F  0522     ANDWF data, W
0F30  1D03     BTFSS STATUS, 0x2
0F31  2F33     GOTO 0x733
0F32  2F34     GOTO 0x734
0F33  2F24     GOTO 0x724
0F34  2F49     GOTO 0x749
67:            		exp++;
0F24  3001     MOVLW 0x1
0F25  00A5     MOVWF p1
0F26  0825     MOVF p1, W
0F27  07A3     ADDWF data, F
68:            		arg >>= 1;
0F28  3001     MOVLW 0x1
0F29  36A2     LSRF data, F
0F2A  0CA1     RRF length, F
0F2B  0CA0     RRF __pcstackBANK0, F
0F2C  0B89     DECFSZ WREG, F
0F2D  2F29     GOTO 0x729
69:            	}
70:            	while(arg & 0xFF0000UL) {
71:            		exp++;
0F35  3001     MOVLW 0x1
0F36  00A5     MOVWF p1
0F37  0825     MOVF p1, W
0F38  07A3     ADDWF data, F
72:            		(arg)++;
0F39  3001     MOVLW 0x1
0F3A  07A0     ADDWF __pcstackBANK0, F
0F3B  3000     MOVLW 0x0
0F3C  1803     BTFSC STATUS, 0x0
0F3D  3001     MOVLW 0x1
0F3E  07A1     ADDWF length, F
0F3F  3000     MOVLW 0x0
0F40  1803     BTFSC STATUS, 0x0
0F41  3001     MOVLW 0x1
0F42  07A2     ADDWF data, F
73:            		arg >>= 1;
0F43  3001     MOVLW 0x1
0F44  36A2     LSRF data, F
0F45  0CA1     RRF length, F
0F46  0CA0     RRF __pcstackBANK0, F
0F47  0B89     DECFSZ WREG, F
0F48  2F44     GOTO 0x744
74:            	}
0F49  30FF     MOVLW 0xFF
0F4A  0522     ANDWF data, W
0F4B  1D03     BTFSS STATUS, 0x2
0F4C  2F4E     GOTO 0x74E
0F4D  2F4F     GOTO 0x74F
0F4E  2F35     GOTO 0x735
0F4F  2F58     GOTO 0x758
75:            	while(!(arg & 0x8000UL) && exp > 1) {
0F58  1BA1     BTFSC length, 0x7
0F59  2F5B     GOTO 0x75B
0F5A  2F5C     GOTO 0x75C
0F5B  2F62     GOTO 0x762
0F5C  3002     MOVLW 0x2
0F5D  0223     SUBWF data, W
0F5E  1803     BTFSC STATUS, 0x0
0F5F  2F61     GOTO 0x761
0F60  2F62     GOTO 0x762
0F61  2F50     GOTO 0x750
76:            		exp--;
0F50  3001     MOVLW 0x1
0F51  02A3     SUBWF data, F
77:            		arg <<= 1;
0F52  3001     MOVLW 0x1
0F53  35A0     LSLF __pcstackBANK0, F
0F54  0DA1     RLF length, F
0F55  0DA2     RLF data, F
0F56  0B89     DECFSZ WREG, F
0F57  2F53     GOTO 0x753
78:            	}
79:            	if(!(exp & 1))
0F62  1823     BTFSC data, 0x0
0F63  2F65     GOTO 0x765
0F64  2F66     GOTO 0x766
0F65  2F6C     GOTO 0x76C
80:            		arg &= ~0x8000L;
0F66  30FF     MOVLW 0xFF
0F67  05A0     ANDWF __pcstackBANK0, F
0F68  307F     MOVLW 0x7F
0F69  05A1     ANDWF length, F
0F6A  30FF     MOVLW 0xFF
0F6B  05A2     ANDWF data, F
81:            	exp >>= 1;
0F6C  1003     BCF STATUS, 0x0
0F6D  0CA3     RRF data, F
82:            	arg |= (__uint24)exp << 16;
0F6E  0823     MOVF data, W
0F6F  00A5     MOVWF p1
0F70  01A6     CLRF p
0F71  01A7     CLRF 0x27
0F72  3010     MOVLW 0x10
0F73  35A5     LSLF p1, F
0F74  0DA6     RLF p, F
0F75  0DA7     RLF 0x27, F
0F76  0B89     DECFSZ WREG, F
0F77  2F73     GOTO 0x773
0F78  0825     MOVF p1, W
0F79  04A0     IORWF __pcstackBANK0, F
0F7A  0826     MOVF p, W
0F7B  04A1     IORWF length, F
0F7C  0827     MOVF 0x27, W
0F7D  04A2     IORWF data, F
83:            	if (sign)
0F7E  0824     MOVF sign, W
0F7F  1903     BTFSC STATUS, 0x2
0F80  2F82     GOTO 0x782
0F81  2F83     GOTO 0x783
0F82  2F84     GOTO 0x784
84:            		arg |= 0x800000UL;
0F83  17A2     BSF data, 0x7
85:               return *(float*)&arg;	
86:            }
0F84  0008     RETURN
87:            
88:            #endif
---  C:/Program Files/Microchip/xc8/v2.30/pic/sources/c90/common/altoft.c  ------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.	
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert signed int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(__uint24 *)&f1)
15:            float
16:            __altoft(signed long int c)
17:            {
18:            	float	f1;
19:            	unsigned char	exp, sign;
20:            	
21:            	if(c == 0)
22:            		return 0.0;
23:            	sign = 0;
24:            	if(c < 0) {
25:            		c = -c;
26:            		sign = 1;
27:            	}
28:            	exp = 127+15;
29:            	// normalize 32 bits to 24 first
30:            	while(c & ~0xFFFFFFUL) {
31:            		*(unsigned long int *)&c >>= 1;
32:            		exp++;
33:            	}
34:            	f1_as_mant1 = c;
35:            	__ftpack(&f1_as_mant1, exp);
36:            	if(sign)
37:            		f1 = -f1;
38:            	return f1;
39:            }
40:            #else
41:            float
42:            __altoft(signed long int c)
43:            {
44:            	unsigned char exp, sign;
45:            	sign = 0;
0D7C  0140     MOVLB 0x0
0D7D  01B5     CLRF sign
46:            	exp = 127+15;
0D7E  308E     MOVLW 0x8E
0D7F  00B2     MOVWF sign
0D80  0832     MOVF sign, W
0D81  00B4     MOVWF exp1
47:            	if (c < 0) {
0D82  1FB1     BTFSS 0x31, 0x7
0D83  2D85     GOTO 0x585
0D84  2D86     GOTO 0x586
0D85  2D9F     GOTO 0x59F
48:            		c = -c;
0D86  09AE     COMF c, F
0D87  09AF     COMF f1, F
0D88  09B0     COMF 0x30, F
0D89  09B1     COMF 0x31, F
0D8A  0AAE     INCF c, F
0D8B  1903     BTFSC STATUS, 0x2
0D8C  0AAF     INCF f1, F
0D8D  1903     BTFSC STATUS, 0x2
0D8E  0AB0     INCF 0x30, F
0D8F  1903     BTFSC STATUS, 0x2
0D90  0AB1     INCF 0x31, F
49:            		sign = 1;
0D91  01B5     CLRF sign
0D92  0AB5     INCF sign, F
0D93  2D9F     GOTO 0x59F
50:            	}
51:            	// normalize 32 bits to 24 first
52:            	while(c & ~0xFFFFFFUL) {
0D9F  30FF     MOVLW 0xFF
0DA0  0531     ANDWF 0x31, W
0DA1  1D03     BTFSS STATUS, 0x2
0DA2  2DA4     GOTO 0x5A4
0DA3  2DA5     GOTO 0x5A5
0DA4  2D94     GOTO 0x594
53:            		*(unsigned long int *)&c >>= 1;
0D94  3001     MOVLW 0x1
0D95  36B1     LSRF 0x31, F
0D96  0CB0     RRF 0x30, F
0D97  0CAF     RRF f1, F
0D98  0CAE     RRF c, F
0D99  0B89     DECFSZ WREG, F
0D9A  2D95     GOTO 0x595
54:            		exp++;
0D9B  3001     MOVLW 0x1
0D9C  00B2     MOVWF sign
0D9D  0832     MOVF sign, W
0D9E  07B4     ADDWF exp1, F
55:            	}
56:            	return __ftpack((__int24)c, exp, sign); 
0DA5  082E     MOVF c, W
0DA6  00A0     MOVWF __pcstackBANK0
0DA7  082F     MOVF f1, W
0DA8  00A1     MOVWF length
0DA9  0830     MOVF 0x30, W
0DAA  00A2     MOVWF data
0DAB  0834     MOVF exp1, W
0DAC  00B2     MOVWF sign
0DAD  0832     MOVF sign, W
0DAE  00A3     MOVWF data
0DAF  0835     MOVF sign, W
0DB0  00B3     MOVWF exp2
0DB1  0833     MOVF exp2, W
0DB2  00A4     MOVWF sign
0DB3  318F     MOVLP 0xF
0DB4  2710     CALL 0x710
0DB5  318D     MOVLP 0xD
0DB6  0140     MOVLB 0x0
0DB7  0820     MOVF __pcstackBANK0, W
0DB8  00AE     MOVWF c
0DB9  0821     MOVF length, W
0DBA  00AF     MOVWF f1
0DBB  0822     MOVF data, W
0DBC  00B0     MOVWF 0x30
57:            }
0DBD  0008     RETURN
58:            #endif
